<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CL LP Exposure Planner — Quote Asset Notional</title>
<style>
  :root {
    --bg:#0b0f14; --card:#101620; --ink:#e8eef6; --muted:#9fb1c7;
    --accent:#5bb0ff; --good:#17c964; --bad:#ff5d5d; --warn:#ffc857;
    --highlight:#334255;
  }
  * { box-sizing:border-box; }
  body {
    margin:0; font:13px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;
    background:var(--bg); color:var(--ink);
  }
  header {
    padding:16px 18px; border-bottom:1px solid #17202d;
    position:sticky; top:0;
    background:linear-gradient(180deg,#0b0f14,#0b0f14f2 70%,transparent);
    z-index:5;
  }
  h1 { margin:0; font-size:15px; letter-spacing:.3px; font-weight:600; }
  .wrap { padding:16px 18px 36px; max-width:2000px; margin:0 auto; }
  .layout-grid { display:grid; grid-template-columns:1.15fr 1fr; gap:14px; align-items:start; }
  
  .card {
    background:var(--card); border:1px solid #17202d; border-radius:16px;
    padding:14px; box-shadow:0 4px 24px rgba(0,0,0,.25); margin-bottom: 14px;
  }
  .card h2 { margin:0 0 8px; font-size:13px; font-weight:600; color:var(--ink); }
  label { display:block; color:var(--muted); font-size:11px; margin:6px 0 3px; }
  input[type=number], select {
    width:100%; padding:8px 10px; border:1px solid #233142;
    border-radius:10px; background:#0c121a; color:var(--ink); outline:none;
    -webkit-appearance: none;
    -moz-appearance: textfield;
  }
  input[readonly] { background: var(--highlight); color: var(--accent); }
  .chk-row { display:flex; align-items:center; gap:8px; margin-top:8px; }
  input[type=checkbox] { width:auto; transform:scale(1.2); cursor:pointer; }
  
  .row { display:grid; grid-template-columns:repeat(3,1fr); gap:8px; }
  .row4 { display:grid; grid-template-columns:repeat(4,1fr); gap:8px; }
  .btns { display:flex; gap:8px; margin-top:12px; }
  button {
    padding:8px 10px; border:1px solid #223146; background:#0e1621;
    color:var(--ink); border-radius:12px; cursor:pointer; transition:.15s ease;
  }
  button.primary {
    background:linear-gradient(180deg,#1b2c43,#142133); border-color:#2d4666;
  }
  button.secondary {
    background: #1a2a3d; border-color: #2d4666; color: #a7c4e6;
  }
  button.secondary:hover {
    background: #23364d;
  }
  .muted { color:var(--muted); font-size:11px; }
  .pill {
    display:inline-block; padding:3px 7px; border-radius:999px;
    border:1px solid #26415f; background:#0f1723;
    font-size:10px; color:#a7c4e6;
  }
  table {
    width:100%; border-collapse:separate; border-spacing:0;
    min-width:1600px; table-layout:auto;
  }
  th, td {
    padding:6px 8px; border-bottom:1px solid #1a2433;
    text-align:right; white-space:nowrap;
  }
  th {
    position:sticky; top:0; background:#0f1622; z-index:2;
    font-weight:600; color:#b9cbe0; white-space:normal; line-height:1.2;
  }
  th:first-child, td:first-child {
    text-align:left; position:sticky; left:0;
    background:linear-gradient(90deg,#0f1622,#0f1622cc); z-index:1;
  }
  .sticky-r {
    position:sticky; right:0;
    background:linear-gradient(270deg,#0f1622,#0f1622cc);
    z-index:4; border-left:1px solid #1a2433;
  }
  .scroll { overflow:auto; border:1px solid #17202d; border-radius:14px; max-height:60vh; }
  .footnote { margin-top:8px; font-size:11px; color:#95a9c2; }
  .kpis {
    display:grid; grid-template-columns:repeat(3,1fr);
    gap:8px; margin-top:8px;
  }
  .kpi {
    padding:10px; border-radius:14px; border:1px solid #1a2a3d;
    background:#0e1622;
  }
  .kpi b { display:block; font-size:11px; color:#a6bdd9; margin-bottom:3px; }
  .kpi div { font-size:15px; font-weight:600; }
  .tag {
    display:inline-block; font-size:10px; padding:2px 6px;
    border-radius:999px; border:1px solid #284d6f; background:#0d1a27;
  }
  .tag.hold { border-color:#2a6f4d; background:#0d2017; }
  .tag.source { border-color:#6f2a2a; background:#27100f; }
  
  .section-header {
    margin: 24px 0 12px; font-size: 16px; font-weight: 700; color: var(--accent);
    display: flex; align-items: center; gap: 8px; border-bottom: 1px solid #17202d; padding-bottom: 8px;
  }
</style>
</head>
<body>
<header>
  <h1>CL LP Exposure Planner — Quote Asset Notional</h1>
</header>

<div class="wrap">
  <!-- Inputs Section -->
  <div class="card">
    <h2>Inputs
      <span class="pill" style="float:right; background:var(--good); border-color:#1c693b;">
        Live Sheets & CoinGecko PRO
      </span>
    </h2>

    <div class="row4" style="margin-top:6px; grid-template-columns:1fr 1fr 2fr;">
      <div>
        <label>Alt asset (Select to load config)</label>
        <select id="assetSelect">
          <option value="">– Select asset –</option>
        </select>
      </div>
      <div>
        <label>Denominated asset</label>
        <select id="denomSelect">
          <option value="BTC" selected>BTC</option>
          <option value="ETH">ETH</option>
          <option value="SOL">SOL</option>
          <option value="BNB">BNB</option>
        </select>
      </div>
      <div>
        <label><span class="denomLabelShort">BTC</span> price (<span class="denomLabelShort">BTC</span>/USD) - Auto-Fetched</label>
        <input type="number" id="denomUsd" step="0.01" value="60000">
      </div>
    </div>
    <div class="footnote" id="sheetStatus" style="margin-bottom:8px; color:var(--warn);">
      Loading asset list from Google Sheet...
    </div>

    <!-- Prices in ALT/Denom -->
    <div class="row">
      <div>
        <label>Price Min (Pmin, ALT/denom)</label>
        <input type="number" id="pmin" step="0.00000001" value="0.00010000">
      </div>
      <div>
        <label>Price Max (Pmax, ALT/denom)</label>
        <input type="number" id="pmax" step="0.00000001" value="0.00035000">
      </div>
      <div>
        <label>Current Price (P₀, ALT/denom)
           <span style="color:var(--good); font-weight:bold; margin-left:4px;" id="p0LiveTag"></span>
        </label>
        <input type="number" id="p0" step="0.00000001" value="0.00020800">
      </div>
    </div>
    
    <div class="row4" style="margin-top:6px; grid-template-columns:1fr 3fr;">
      <div>
        <label>Current ALT price (derived)</label>
        <div class="muted" id="altPriceSummary">Set P₀ and denom price to see ALT/USD.</div>
      </div>
      <div>
        <!-- Exposed JLP Price for JLP Mode visibility -->
        <label style="color:var(--accent);">JLP Price (USD, for JLP Mode)</label>
        <input type="number" id="jlpUsd" step="0.001" value="0" style="width:120px; border-color:var(--accent);">
      </div>
    </div>

    <!-- Portfolio + target % -->
    <div class="row4" style="margin-top:6px;">
      <div>
        <label>Total Portfolio size (<span class="denomLabelShort">BTC</span>)</label>
        <input type="number" id="portfolioSize" step="0.0001" value="0">
      </div>
      <div>
        <label>Target net exposure @ Pmin (% of portfolio)</label>
        <input type="number" id="targetMinPct" step="0.01" value="0">
      </div>
      <div>
        <label>Target net exposure @ Pmax (% of portfolio)</label>
        <input type="number" id="targetMaxPct" step="0.01" value="-100">
      </div>
      <div style="display:flex; flex-direction:column; gap:6px;">
         <div class="chk-row">
            <input type="checkbox" id="dualLpMode">
            <label for="dualLpMode" style="margin:0; font-size:12px; color:var(--ink); font-weight:600;">Dual LP (50/50 Split)</label>
         </div>
         <div class="chk-row">
            <input type="checkbox" id="jlpStrategyMode">
            <label for="jlpStrategyMode" style="margin:0; font-size:12px; color:var(--accent); font-weight:600;">JLP Mode (Hedged)</label>
         </div>
         <div class="chk-row">
            <input type="checkbox" id="quadLpMode">
            <label for="quadLpMode" style="margin:0; font-size:12px; color:#e08aff; font-weight:600;">Quad Split (25% Each)</label>
         </div>
      </div>
    </div>

    <!-- Interval + current E + auto targets -->
    <div class="row4" style="margin-top:6px;">
      <div>
        <label>Interval size (%)</label>
        <input type="number" id="intervalPct" step="0.01" value="1">
      </div>
      <div>
        <label>Current Net Exposure (<span class="denomLabelShort">BTC</span>)
          <span class="muted">(ALT + short, before LP)</span>
        </label>
        <input type="number" id="currentE" step="0.0001" value="0">
      </div>
      <div>
        <label>Target @ Pmin (<span class="denomLabelShort">BTC</span>, auto)</label>
        <input type="number" id="targetMin" step="0.0001" value="0" readonly>
      </div>
      <div>
        <label>Target @ Pmax (<span class="denomLabelShort">BTC</span>, auto)</label>
        <input type="number" id="targetMax" step="0.0001" value="0" readonly>
      </div>
    </div>

    <!-- Misc config -->
    <div class="row4" style="margin-top:6px;">
      <div>
        <label>Precision decimals</label>
        <input type="number" id="dec" step="1" value="4">
      </div>
      <div>
        <label>Assume current exposure scales with price?</label>
        <select id="scaleMode">
          <option value="scale">Scale linearly with price (default)</option>
          <option value="noscale">Do not scale current exposure</option>
        </select>
      </div>
      <div>
        <label>Cap rows (optional)</label>
        <input type="number" id="capRows" step="1" placeholder="">
      </div>
      <div>
        <label>Show zero-only rows?</label>
        <select id="showZeros">
          <option value="hide">Hide</option>
          <option value="show">Show</option>
        </select>
      </div>
    </div>

    <!-- APR -->
    <div class="row4" style="margin-top:6px;">
      <div>
        <label>LP APR on total capital (%)</label>
        <input type="number" id="aprPct" step="0.01" value="20">
      </div>
      <div>
        <label>Max days in-range to simulate</label>
        <input type="number" id="maxDays" step="1" value="365">
      </div>
    </div>

    <div class="btns">
      <button class="primary" id="btn">Generate Schedules</button>
      <button id="btnClear">Clear Tables</button>
    </div>
  </div>
  
  <div id="resultsContainer"></div>
  
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
// --- START: GOOGLE APPS SCRIPT URL ---
const APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbzqG0z2v6nZZZpuhGVYHR28R71jpKl4psheB3bsMQ1bj2Hc4-590l-7Xgj8LUG6cFryMw/exec';
// --- END: GOOGLE APPS SCRIPT URL ---

const COINGECKO_IDS = {
  BTC: 'bitcoin', ETH: 'ethereum', SOL: 'solana', BNB: 'binancecoin',
  ARB: 'arbitrum', OP: 'optimism', TIA: 'celestia', MATIC: 'matic-network',
  LINK: 'chainlink', AVAX: 'avalanche-2', DOGE: 'dogecoin', ADA: 'cardano',
  XRP: 'ripple', LDO: 'lido-dao', UNI: 'uniswap', ASTER: 'aster-2',
  JLP: 'jupiter-perpetuals-liquidity-provider-token'
};

function fmt(x, d){
  if(!isFinite(x)) return '–';
  const s = Number(x).toFixed(d);
  return Number(s).toLocaleString(undefined,{minimumFractionDigits:d, maximumFractionDigits:d});
}

function fmtDenom(x, denomDecimals, denomUsd, denomSymbol){
  if(!isFinite(x)) return '–';
  const denomStr = fmt(x, denomDecimals) + ' ' + denomSymbol;
  // If denom IS USD, don't show the duplicate USD value
  if(denomSymbol === 'USD' || !(denomUsd > 0)) return denomStr;
  const usdStr = fmt(x * denomUsd, 2) + ' USD';
  return denomStr + ' / ' + usdStr;
}

function updateAltPriceSummary(){
  const p0El = document.getElementById('p0');
  const denomUsdEl = document.getElementById('denomUsd');
  const out = document.getElementById('altPriceSummary');
  if(!p0El || !denomUsdEl || !out) return;
  const p0 = Number(p0El.value || 0);
  const denomUsd = Number(denomUsdEl.value || 0);
  const denomSym = (document.getElementById('denomSelect')?.value || 'BTC').toUpperCase();
  const assetSym = (document.getElementById('assetSelect')?.value || 'ALT').toUpperCase();
  if(!(p0 > 0 && denomUsd > 0)){
    out.textContent = 'Set P₀ and ' + denomSym + '/USD to see ' + assetSym + '/USD.';
    return;
  }
  const altUsd = p0 * denomUsd;
  out.textContent = assetSym + ' = ' + fmt(p0, 8) + ' ' + denomSym +
                    ' ≈ ' + fmt(altUsd, 4) + ' USD';
}

function updateDenomLabels(sym){
  const s = sym || 'BTC';
  document.querySelectorAll('.denomLabelShort').forEach(el => { el.textContent = s; });
}

async function autoFetchPrices(assetSym, denomSym){
  const p0LiveTag = document.getElementById('p0LiveTag');
  if(p0LiveTag) p0LiveTag.textContent = '';

  const assetId = COINGECKO_IDS[(assetSym || '').toUpperCase()];
  const denomId = COINGECKO_IDS[(denomSym || '').toUpperCase()];
  const jlpId   = COINGECKO_IDS['JLP'];

  if(!denomId){
    console.log('No denom ID found for auto-fetch');
    return;
  }

  let idsToFetch = denomId;
  if(assetId) idsToFetch += ',' + assetId;
  if(jlpId)   idsToFetch += ',' + jlpId;

  try {
    if (window.location.protocol === 'file:' || window.location.protocol === 'blob:') {
      console.log("Environment check: Vercel API is not available in local preview. Skipping price fetch.");
      const sheetStatus = document.getElementById('sheetStatus');
      if(sheetStatus) sheetStatus.innerHTML += ' <span style="color:var(--warn)">(Live prices require Vercel deployment)</span>';
      return;
    }

    const url = `/api/price?ids=${encodeURIComponent(idsToFetch)}&vs_currencies=usd`;
    const res = await fetch(url);
    if(!res.ok) throw new Error('HTTP ' + res.status);
    const data = await res.json();

    const denomPriceUsd = data[denomId]?.usd;
    
    if(denomPriceUsd){
      const denomUsdEl = document.getElementById('denomUsd');
      if(denomUsdEl) denomUsdEl.value = denomPriceUsd;
    }

    if(jlpId && data[jlpId]?.usd){
       document.getElementById('jlpUsd').value = data[jlpId].usd;
    }

    if(assetId && data[assetId]?.usd && denomPriceUsd){
      const assetPriceUsd = data[assetId].usd;
      const derivedP0 = assetPriceUsd / denomPriceUsd;
      
      const p0El = document.getElementById('p0');
      if(p0El){
        p0El.value = derivedP0.toFixed(8);
        if(p0LiveTag) p0LiveTag.textContent = '(Live)';
        console.log(`Auto-calculated P0 for ${assetSym}/${denomSym}: ${derivedP0}`);
      }
    }

    updateAltPriceSummary();
    generate();

  } catch(err){
    console.error('Error fetching prices:', err);
  }
}

async function loadAssetList(){
  const sel = document.getElementById('assetSelect');
  const statusEl = document.getElementById('sheetStatus');
  if(!sel || !statusEl || APPS_SCRIPT_URL.includes('YOUR_APPS_SCRIPT')) {
    statusEl.innerHTML = '<span style="color:var(--bad)">ERROR:</span> Check APPS_SCRIPT_URL.';
    return;
  }

  statusEl.textContent = 'Loading asset list from Google Sheet...';
  sel.innerHTML = '<option value="">– Select asset –</option>';
  
  try{
    const res = await fetch(APPS_SCRIPT_URL);
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    
    if(data.error){
       throw new Error(data.error);
    }
    
    if(data.assets && Array.isArray(data.assets)){
      data.assets.forEach(sym => {
        if(sym && String(sym).trim() !== ''){
          const opt = document.createElement('option');
          opt.value = String(sym).trim();
          opt.textContent = String(sym).trim();
          sel.appendChild(opt);
        }
      });
      statusEl.textContent = `Successfully loaded ${data.assets.length} assets from Google Sheet.`;
    } else {
      throw new Error('Invalid data structure returned from Google Sheet.');
    }
  }catch(err){
    console.error('Error loading asset list', err);
    statusEl.innerHTML = `<span style="color:var(--bad)">ERROR:</span> Failed to load asset list. (${err.message})`;
  }
}

async function loadAssetConfig(symbol){
  if(!symbol) return;
  
  const statusEl = document.getElementById('sheetStatus');
  statusEl.textContent = `Loading config for ${symbol} from Google Sheet...`;

  try{
    const url = `${APPS_SCRIPT_URL}?symbol=${encodeURIComponent(symbol)}`;
    const res = await fetch(url);
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();

    if(data.error) throw new Error(data.error);

    if(typeof data.pmin === 'number') document.getElementById('pmin').value = data.pmin;
    if(typeof data.pmax === 'number') document.getElementById('pmax').value = data.pmax;
    if(typeof data.p0   === 'number') document.getElementById('p0').value   = data.p0;
    if(typeof data.currentE === 'number') document.getElementById('currentE').value = data.currentE;
    if(typeof data.portfolioSize === 'number') document.getElementById('portfolioSize').value = data.portfolioSize;
    if(typeof data.targetMinPct === 'number') document.getElementById('targetMinPct').value = data.targetMinPct;
    if(typeof data.targetMaxPct === 'number') document.getElementById('targetMaxPct').value = data.targetMaxPct;

    let denomSym = 'BTC';
    if(data.denomAsset){
      const dSel = document.getElementById('denomSelect');
      if(dSel){
        dSel.value = data.denomAsset;
        updateDenomLabels(data.denomAsset);
        denomSym = data.denomAsset;
      }
    }
    
    await autoFetchPrices(symbol, denomSym);
    updateAltPriceSummary();
    generate();
    statusEl.textContent = `Config for ${symbol} loaded. Prices auto-updated.`;

  }catch(err){
    console.error('Error loading config', err);
    statusEl.innerHTML = `<span style="color:var(--bad)">ERROR:</span> Failed to load ${symbol}. (${err.message})`;
  }
}

function buildBands(pmin, pmax, p0, stepPct){
  const down = [], up = [];
  let p = p0;
  while(p > pmin){
    const pb = p;
    const pa = Math.max(pmin, pb * (1 - stepPct/100));
    down.push({pa, pb, type:'Below'});
    if(pa === pmin) break;
    p = pa;
  }
  p = p0;
  while(p < pmax){
    const pa = p;
    const pb = Math.min(pmax, pa * (1 + stepPct/100));
    up.push({pa, pb, type:'Above'});
    if(pb === pmax) break;
    p = pb;
  }
  return {down, up};
}

// --------------------------------------------------------------------------
// Core Logic: Calculates strategy for ONE LP setup
// --------------------------------------------------------------------------
function calculateStrategy(params) {
  const {
    pmin, pmax, p0, stepPct,
    portfolioSize, targetMinPct, targetMaxPct, currentE,
    denomSymbol, denomUsd, assetSymbol,
    scaleMode, aprPct, maxDays
  } = params;

  if(!(pmin>0 && pmax>pmin && p0>0 && p0>=pmin && p0<=pmax)) {
     console.error('Invalid parameters for Strategy:', params);
     return null;
  }

  const bands = buildBands(pmin, pmax, p0, stepPct);
  const Ndown = bands.down.length, Nup = bands.up.length;
  
  const targetMin = portfolioSize * targetMinPct / 100;
  const targetMax = portfolioSize * targetMaxPct / 100;

  const scaleFactorAt = (px) => (scaleMode === 'scale' ? (px/p0) : 1);

  const currentAtMin = currentE * scaleFactorAt(pmin);
  const needMinDelta = (targetMin - currentAtMin);
  
  let sumRdown = 0;
  for(const b of bands.down){
    b.r_down = Math.sqrt(b.pa / b.pb);
    sumRdown += b.r_down;
  }
  const perUsdBelow = sumRdown>0 ? (needMinDelta / sumRdown) : 0;

  for(const b of bands.up){ b.r_up = Math.sqrt(b.pb / b.pa); }
  const sumRup = bands.up.reduce((s,b)=> s + b.r_up, 0);

  const currentAtMax = currentE * scaleFactorAt(pmax);
  const needMoreNegativeAtMax = currentAtMax - targetMax;
  const perAltUsdNeeded = sumRup>0 ? (needMoreNegativeAtMax / sumRup) : 0;
  let aboveTotalNeeded = perAltUsdNeeded * Nup;

  let holdingsAvail = Math.max(currentE, 0);
  let buyShortAllowed = (targetMax < 0);
  
  let aboveTotalScheduled = aboveTotalNeeded;
  let holdingsUsed = 0;
  let toBuyShort = 0;

  if(Nup === 0) aboveTotalScheduled = 0;

  if(currentE > 0 && targetMax === 0){
    aboveTotalScheduled = Math.min(aboveTotalNeeded, holdingsAvail);
    holdingsUsed = aboveTotalScheduled;
  } else {
    holdingsUsed = Math.min(holdingsAvail, aboveTotalNeeded);
    toBuyShort = Math.max(0, aboveTotalNeeded - holdingsUsed);
    if(!buyShortAllowed){
      aboveTotalScheduled = holdingsUsed;
      toBuyShort = 0;
    }
  }

  const perAltUsdSchedule = Nup>0 ? (aboveTotalScheduled / Nup) : 0;
  
  // Generating Rows
  const rows = [];
  let belowTotal = 0, aboveTotal = 0;
  let cumBelowValue = 0, cumAboveSale = 0;
  let holdingsRemaining = holdingsUsed;
  let startBuyShortPx = null;
  
  const ordered = [...bands.down, ...bands.up];
  
  // APR
  const dailyRate = aprPct > 0 ? (aprPct / 100 / 365) : 0;
  const totalCapitalAPR = (perUsdBelow * Ndown) + aboveTotalScheduled;

  ordered.forEach((b, idx) => {
    const isDown = (b.type === 'Below');
    const rdown = isDown ? b.r_down : 0;
    const rup = !isDown ? b.r_up : 0;
    const boundaryPx = isDown ? b.pa : b.pb;

    let deployUSD = 0, valueAtPa = 0, deployAltUsd = 0, saleAtPb = 0, sourceTag = '';

    if(isDown){
      deployUSD = perUsdBelow;
      valueAtPa = deployUSD * rdown;
      belowTotal += deployUSD;
      cumBelowValue += valueAtPa;
    } else {
      if(aboveTotal < aboveTotalScheduled - 1e-12){
        deployAltUsd = Math.min(perAltUsdSchedule, aboveTotalScheduled - aboveTotal);
        aboveTotal += deployAltUsd;
        
        let useHold = 0;
        if(holdingsRemaining > 0){
          useHold = Math.min(deployAltUsd, holdingsRemaining);
          holdingsRemaining -= useHold;
          sourceTag = '<span class="tag hold">Holdings</span>';
          if(deployAltUsd - useHold > 1e-12){
            sourceTag += ' + <span class="tag source">Buy+Short</span>';
            if(startBuyShortPx===null) startBuyShortPx = b.pa;
          }
        } else {
          sourceTag = '<span class="tag source">Buy+Short</span>';
          if(startBuyShortPx===null) startBuyShortPx = b.pa;
        }
        saleAtPb = deployAltUsd * rup;
        cumAboveSale += saleAtPb;
      }
    }
    
    const baseE = currentE * scaleFactorAt(boundaryPx);
    const netAtBoundary = isDown ? (baseE + cumBelowValue) : (baseE - cumAboveSale);
    const altUnitsAbove = (!isDown && deployAltUsd>0) ? (deployAltUsd / b.pa) : 0;
    const pnlAtBoundary = netAtBoundary - baseE;
    
    let daysToBE = null;
    if(dailyRate > 0 && totalCapitalAPR > 0 && pnlAtBoundary < 0){
      const ratio = 1 - (pnlAtBoundary / totalCapitalAPR);
      if(ratio > 1) daysToBE = Math.log(ratio) / Math.log(1 + dailyRate);
    }
    
    rows.push({
      bandIdx: idx + 1,
      pa: b.pa, pb: b.pb, type: b.type,
      r_down: rdown, r_up: rup,
      deployUSD, valueAtPa, deployAltUsd, sourceTag, saleAtPb,
      altUnitsAbove, netAtBoundary, pnlAtBoundary, daysToBE
    });
  });

  const netAtPmin = (currentE * scaleFactorAt(pmin)) + bands.down.reduce((s,b)=>s + perUsdBelow*Math.sqrt(b.pa/b.pb),0);
  const netAtPmax = (currentE * scaleFactorAt(pmax)) - bands.up.reduce((s,b)=>s + perAltUsdSchedule*Math.sqrt(b.pb/b.pa),0);
  
  return {
    rows,
    kpi: {
      Ndown, Nup,
      belowTotal, aboveTotal: aboveTotalScheduled,
      resMin: netAtPmin - targetMin,
      resMax: netAtPmax - targetMax,
      holdingsUsed,
      toBuyShort: (toBuyShort && buyShortAllowed ? toBuyShort : 0),
      startBuyShortPx
    },
    apr: { totalCapitalAPR, dailyRate, maxDays, negRows: rows.filter(r=>r.pnlAtBoundary<0) }
  };
}

// --------------------------------------------------------------------------
// NEW: Quad LP Breakdown Renderer
// --------------------------------------------------------------------------
function renderQuadAggregateTable(container, strategies) {
  const ref = strategies[0]; // Ref
  const q1 = strategies[1]; // SOL/USD
  const q2 = strategies[2]; // SOL/BTC
  const q3 = strategies[3]; // JLP/USDC
  const q4 = strategies[4]; // SOL/JLP
  
  // Helper to grab row data
  const getRows = (s) => s.data ? s.data.rows : [];
  const refRows = getRows(ref);
  const q1Rows = getRows(q1);
  const q2Rows = getRows(q2);
  const q3Rows = getRows(q3);
  const q4Rows = getRows(q4);
  
  // We assume alignment by index
  if(refRows.length === 0) return;

  // Prices for conversion
  const denomUsd = ref.params.denomUsd || 1; 
  const btcPrice = q2.params.denomUsd || 1; // Price of denom for Q2 (BTC)
  const jlpUsd = q4.params.denomUsd || 1; // Price of denom for Q4 (JLP)
  // Implied SOL Price from P0 (SOL/BTC) * BTC Price
  const p0 = Number(document.getElementById('p0').value) || 0;
  const solPriceUsd = p0 * btcPrice; 

  const html = `
    <div class="section-header" style="color:#e08aff; border-bottom-color:#e08aff;">
      Quad LP Breakdown: Per-Band Allocation Check
    </div>
    <div class="card" style="margin-top:10px;">
      <div class="footnote" style="margin-bottom:8px; color:var(--muted);">
        Breakdown of how the 4 split LPs (25% capital each) sum up to match the Reference (100% capital).<br>
        <b>Below (USD Target):</b> Q1+Q3 + Q2(BTC->USD) + 50% of Q4(JLP->USD).<br>
        <b>Above (SOL Target):</b> Q1+Q2+Q4 + 50% of Q3(JLP->SOL).
      </div>
      <div class="scroll">
        <table>
          <thead>
            <tr>
              <th>Band</th>
              <th>Type</th>
              <th>Target (Ref)</th>
              <th>Q1 (SOL/USD)</th>
              <th>Q2 (SOL/BTC)</th>
              <th>Q3 (JLP/USDC)</th>
              <th>Q4 (SOL/JLP)</th>
              <th>Actual Sum</th>
              <th>Diff</th>
            </tr>
          </thead>
          <tbody>
            ${refRows.map((r, i) => {
               const r1 = q1Rows[i] || {};
               const r2 = q2Rows[i] || {};
               const r3 = q3Rows[i] || {};
               const r4 = q4Rows[i] || {};
               
               let targetVal = 0;
               let v1=0, v2=0, v3=0, v4=0;
               let sumVal = 0;
               let unit = '';

               if(r.type === 'Below') {
                 // Target: USD Amount
                 targetVal = r.deployUSD; 
                 unit = 'USD';
                 
                 // Q1: USD -> r1.deployUSD is USD
                 v1 = r1.deployUSD || 0;
                 
                 // Q2: BTC -> r2.deployUSD is BTC -> Convert to USD
                 v2 = (r2.deployUSD || 0) * btcPrice;
                 
                 // Q3: USDC -> r3.deployUSD is USDC (USD)
                 v3 = r3.deployUSD || 0;
                 
                 // Q4: JLP -> r4.deployUSD is JLP. JLP = 50% USD.
                 // We deploy JLP (quote). 50% of that value acts as USD.
                 v4 = (r4.deployUSD || 0) * jlpUsd * 0.5; 
                 
               } else {
                 // Target: SOL Amount (Inventory)
                 targetVal = r.altUnitsAbove;
                 unit = 'SOL';
                 
                 // Q1: SOL
                 v1 = r1.altUnitsAbove || 0;
                 
                 // Q2: SOL
                 v2 = r2.altUnitsAbove || 0;
                 
                 // Q3: JLP -> r3.altUnitsAbove is JLP Units (Base).
                 // JLP = 50% SOL. Convert JLP Units to SOL content.
                 const jlpAmt = r3.altUnitsAbove || 0;
                 if(solPriceUsd > 0) {
                    // Value of JLP in USD = jlpAmt * jlpUsd
                    // SOL part is 50% of that value = 0.5 * Value
                    // SOL units = (0.5 * Value) / SolPrice
                    v3 = (jlpAmt * jlpUsd * 0.5) / solPriceUsd;
                 }
                 
                 // Q4: SOL
                 v4 = r4.altUnitsAbove || 0;
               }
               
               sumVal = v1 + v2 + v3 + v4;
               const diff = sumVal - targetVal;
               const diffPct = (targetVal > 0) ? (diff / targetVal * 100) : 0;
               
               if((document.getElementById('showZeros').value!=='show') && (targetVal < 1e-9)) return '';

               return `<tr>
                 <td style="text-align:left">${r.bandIdx}</td>
                 <td>${r.type}</td>
                 <td style="font-weight:bold; color:var(--accent);">${fmt(targetVal, 4)} ${unit}</td>
                 <td style="color:#888;">${fmt(v1, 4)}</td>
                 <td style="color:#888;">${fmt(v2, 4)}</td>
                 <td style="color:#888;">${fmt(v3, 4)}</td>
                 <td style="color:#888;">${fmt(v4, 4)}</td>
                 <td style="font-weight:bold;">${fmt(sumVal, 4)} ${unit}</td>
                 <td style="color:${Math.abs(diffPct)>5?'var(--bad)':'var(--good)'}; font-size:11px;">
                   ${diff>0?'+':''}${fmt(diff, 2)} (${fmt(diffPct, 1)}%)
                 </td>
               </tr>`;
            }).join('')}
          </tbody>
        </table>
      </div>
    </div>
  `;
  
  const div = document.createElement('div');
  div.innerHTML = html;
  container.appendChild(div);
}

// --------------------------------------------------------------------------
// Rendering Logic
// --------------------------------------------------------------------------
function renderLPSection(container, title, strategyData, denomSymbol, denomUsd, assetSymbol, lpId) {
  if(!strategyData) return;
  const { rows, kpi, apr } = strategyData;
  const dec = parseInt(document.getElementById('dec').value || '4', 10);
  
  // HTML Template for an LP Section
  const sectionHtml = `
    <div class="section-header">${title}</div>
    <div class="layout-grid">
      <!-- KPIs -->
      <div class="card">
        <h2>Quick KPIs</h2>
        <div class="kpis">
          <div class="kpi"><b>Total Deploy Below (${denomSymbol})</b><div>${fmtDenom(kpi.belowTotal, 6, denomUsd, denomSymbol)}</div></div>
          <div class="kpi"><b>Total Deploy Above (${denomSymbol})</b><div>${fmtDenom(kpi.aboveTotal, 6, denomUsd, denomSymbol)}</div></div>
          <div class="kpi"><b>Intervals</b><div>${kpi.Ndown} ↓ / ${kpi.Nup} ↑</div></div>
          <div class="kpi"><b>Residual @ Pmin</b><div>${fmtDenom(kpi.resMin, 6, denomUsd, denomSymbol)}</div></div>
          <div class="kpi"><b>Residual @ Pmax</b><div>${fmtDenom(kpi.resMax, 6, denomUsd, denomSymbol)}</div></div>
          <div class="kpi"><b>Funded from Holdings</b><div>${fmtDenom(kpi.holdingsUsed, 6, denomUsd, denomSymbol)}</div></div>
          <div class="kpi"><b>To Buy+Short</b><div>${fmtDenom(kpi.toBuyShort, 6, denomUsd, denomSymbol)}</div></div>
        </div>
      </div>
      
      <!-- APR Charts Placeholder -->
      <div class="card">
        <h2>APR & PnL Analytics</h2>
        <div class="row4">
           <div><select id="priceSelect_${lpId}" style="width:100%"></select></div>
        </div>
        <div style="margin-top:12px; height:180px;"><canvas id="chart_${lpId}" style="max-height:100%;"></canvas></div>
      </div>
    </div>

    <!-- Table -->
    <div class="card" style="margin-top:14px;">
      <h2>Schedule — ${assetSymbol} / ${denomSymbol}</h2>
      <div class="scroll">
        <table>
          <thead>
            <tr>
              <th>Band</th> <th>p<sub>a</sub></th> <th>p<sub>b</sub></th> <th>Type</th>
              <th>Deploy (${denomSymbol} ↓)</th>
              <th>Value @ p<sub>a</sub> (to ${assetSymbol})</th>
              <th>Deploy ${assetSymbol} value @ P₀ (${assetSymbol} / ${denomSymbol} ↑)</th>
              <th>Source</th>
              <th>Sale @ p<sub>b</sub> (${denomSymbol} ↑)</th>
              <th>Net Exposure (${denomSymbol})</th>
              <th>PnL (${denomSymbol})</th>
              <th class="sticky-r">Days to BE</th>
            </tr>
          </thead>
          <tbody>
             ${rows.map(r => {
               // Special display for "Deploy ALT value"
               
               let altValDisplay = '';
               // Calculate display values
               const altAmt = r.altUnitsAbove; 
               const usdVal = r.deployAltUsd * denomUsd;
               
               if(r.type === 'Above' && r.deployAltUsd > 1e-12) {
                 altValDisplay = fmt(altAmt, 6) + ' ' + assetSymbol + ' / ' + fmt(usdVal, 2) + (denomSymbol==='USD'?'':' USD');
               } else {
                 altValDisplay = fmtDenom(r.deployAltUsd, 6, denomUsd, denomSymbol);
               }

               if((document.getElementById('showZeros').value!=='show') && (r.deployUSD + r.deployAltUsd < 1e-12)) return '';
               
               return `<tr>
                 <td style="text-align:left">${r.type==='Below'?'↓':'↑'} ${r.bandIdx}</td>
                 <td>${fmt(r.pa, 6)}</td> <td>${fmt(r.pb, 6)}</td> <td>${r.type}</td>
                 <td>${fmtDenom(r.deployUSD, 6, denomUsd, denomSymbol)}</td>
                 <td>${fmtDenom(r.valueAtPa, 6, denomUsd, denomSymbol)}</td>
                 <td>${altValDisplay}</td>
                 <td style="text-align:left">${r.sourceTag}</td>
                 <td>${fmtDenom(r.saleAtPb, 6, denomUsd, denomSymbol)}</td>
                 <td>${fmtDenom(r.netAtBoundary, 6, denomUsd, denomSymbol)}</td>
                 <td>${fmtDenom(r.pnlAtBoundary, 6, denomUsd, denomSymbol)}</td>
                 <td class="sticky-r">${r.daysToBE!==null ? r.daysToBE.toFixed(2) : ''}</td>
               </tr>`;
             }).join('')}
          </tbody>
        </table>
      </div>
      <div style="margin-top:8px;">
         <button class="secondary" onclick="copyTable('${lpId}')">Copy Table</button>
      </div>
    </div>
  `;
  
  const div = document.createElement('div');
  div.id = 'section_' + lpId;
  div.innerHTML = sectionHtml;
  container.appendChild(div);

  // Setup Chart
  const ctx = document.getElementById(`chart_${lpId}`);
  if(ctx && apr.negRows.length > 0) {
    new Chart(ctx.getContext('2d'), {
      type:'line',
      data: {
        labels: Array.from({length: apr.maxDays+1}, (_, i) => i),
        datasets: [{
          label: 'PnL (' + denomSymbol + ') @ Selected Boundary',
          data: Array.from({length: apr.maxDays+1}, (_, d) => 
            (apr.negRows[0].pnlAtBoundary + apr.totalCapitalAPR * (Math.pow(1 + apr.dailyRate, d) - 1))
          ),
          borderColor: '#5bb0ff', tension: 0.1
        }]
      },
      options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{x:{display:false}, y:{display:false}} }
    });
  }
}

// --------------------------------------------------------------------------
// Main Execution
// --------------------------------------------------------------------------
function generate() {
  const container = document.getElementById('resultsContainer');
  container.innerHTML = '';

  // 1. Gather Inputs
  const assetSymbol = (document.getElementById('assetSelect').value || 'ALT').toUpperCase();
  const denomSymbol = (document.getElementById('denomSelect').value || 'BTC').toUpperCase();
  const denomUsd = Number(document.getElementById('denomUsd').value || 0);
  
  const pmin = Number(document.getElementById('pmin').value);
  const pmax = Number(document.getElementById('pmax').value);
  const p0 = Number(document.getElementById('p0').value);
  const stepPct = Number(document.getElementById('intervalPct').value);
  
  const portfolioSize = Number(document.getElementById('portfolioSize').value);
  const currentE = Number(document.getElementById('currentE').value);
  
  const targetMinPct = Number(document.getElementById('targetMinPct').value);
  const targetMaxPct = Number(document.getElementById('targetMaxPct').value);
  
  const isDual = document.getElementById('dualLpMode').checked;
  const isJlpMode = document.getElementById('jlpStrategyMode').checked;
  const isQuadMode = document.getElementById('quadLpMode').checked;

  const strategies = [];

  // =======================================================================
  // MODE: QUAD SPLIT (4 Ways: SOL/USD, SOL/BTC, JLP/USD, SOL/JLP)
  // =======================================================================
  if (isQuadMode) {
     // A. Reference: Single SOL/USD Strategy
     // We treat the inputs as pure USD inputs for visualization
     const solPminUsd = pmin * denomUsd;
     const solPmaxUsd = pmax * denomUsd;
     const solP0Usd   = p0   * denomUsd;
     const totalUsdPort = portfolioSize * denomUsd;
     const totalUsdCurE = currentE * denomUsd;

     strategies.push({
      title: `Reference: Single ${assetSymbol}/USD LP (100% Allocation)`,
      id: 'ref',
      params: {
        pmin: solPminUsd, pmax: solPmaxUsd, p0: solP0Usd, stepPct,
        portfolioSize: totalUsdPort,
        currentE: totalUsdCurE,
        targetMinPct, targetMaxPct,
        denomSymbol: 'USD', denomUsd: 1, assetSymbol: assetSymbol,
        scaleMode: document.getElementById('scaleMode').value,
        aprPct: Number(document.getElementById('aprPct').value),
        maxDays: Number(document.getElementById('maxDays').value)
      }
    });

    // B. The 4 Splits (25% Capital Each)
    const quarterPortUsd = totalUsdPort * 0.25;
    const quarterCurrUsd = totalUsdCurE * 0.25;

    // 1. SOL/USD (25%)
    strategies.push({
      title: `1. ${assetSymbol} / USD (25% Cap)`,
      id: 'q1',
      params: {
        pmin: solPminUsd, pmax: solPmaxUsd, p0: solP0Usd, stepPct,
        portfolioSize: quarterPortUsd,
        currentE: quarterCurrUsd,
        targetMinPct, targetMaxPct,
        denomSymbol: 'USD', denomUsd: 1, assetSymbol: assetSymbol,
        scaleMode: document.getElementById('scaleMode').value,
        aprPct: Number(document.getElementById('aprPct').value),
        maxDays: Number(document.getElementById('maxDays').value)
      }
    });

    // 2. SOL/BTC (25%) - Converted back to BTC terms
    // pmin/pmax inputs are ALREADY in BTC terms!
    strategies.push({
      title: `2. ${assetSymbol} / ${denomSymbol} (25% Cap)`,
      id: 'q2',
      params: {
        pmin: pmin, pmax: pmax, p0: p0, stepPct,
        portfolioSize: portfolioSize * 0.25, // BTC
        currentE: currentE * 0.25, // BTC
        targetMinPct, targetMaxPct,
        denomSymbol: denomSymbol, denomUsd: denomUsd, assetSymbol: assetSymbol,
        scaleMode: document.getElementById('scaleMode').value,
        aprPct: Number(document.getElementById('aprPct').value),
        maxDays: Number(document.getElementById('maxDays').value)
      }
    });

    // 3. JLP/USDC (25%) - Dampened + 2x Target
    // Fallback logic for JLP Price
    const jlpInputVal = Number(document.getElementById('jlpUsd').value);
    const jlpUsdLive = (jlpInputVal > 0) ? jlpInputVal : (solP0Usd * 0.5); 
    if(jlpInputVal <= 0 && jlpUsdLive > 0) document.getElementById('jlpUsd').value = jlpUsdLive.toFixed(3);
    
    const getJlpPrice = (solPrice) => jlpUsdLive * (0.5 * (solPrice / solP0Usd) + 0.5);
    const jlpPmin = getJlpPrice(solPminUsd);
    const jlpPmax = getJlpPrice(solPmaxUsd);
    const jlpP0   = jlpUsdLive;

    strategies.push({
      title: `3. JLP / USDC (25% Cap, Dampened Range, 2x Exposure)`,
      id: 'q3',
      params: {
        pmin: jlpPmin, pmax: jlpPmax, p0: jlpP0, stepPct,
        portfolioSize: quarterPortUsd,
        currentE: quarterCurrUsd,
        targetMinPct: targetMinPct * 2, // 2x Scaling
        targetMaxPct: targetMaxPct * 2,
        denomSymbol: 'USDC', denomUsd: 1, assetSymbol: 'JLP',
        scaleMode: document.getElementById('scaleMode').value,
        aprPct: Number(document.getElementById('aprPct').value),
        maxDays: Number(document.getElementById('maxDays').value)
      }
    });

    // 4. SOL/JLP (25%) - Ratio + 2x Target
    const ratioPmin = solPminUsd / getJlpPrice(solPminUsd);
    const ratioPmax = solPmaxUsd / getJlpPrice(solPmaxUsd);
    const ratioP0   = solP0Usd / jlpUsdLive;

    strategies.push({
      title: `4. ${assetSymbol} / JLP (25% Cap, Ratio Range, 2x Exposure)`,
      id: 'q4',
      params: {
        pmin: ratioPmin, pmax: ratioPmax, p0: ratioP0, stepPct,
        portfolioSize: quarterPortUsd / jlpUsdLive, // JLP Terms
        currentE: quarterCurrUsd / jlpUsdLive,
        targetMinPct: targetMinPct * 2, 
        targetMaxPct: targetMaxPct * 2,
        denomSymbol: 'JLP', denomUsd: jlpUsdLive, assetSymbol: assetSymbol,
        scaleMode: document.getElementById('scaleMode').value,
        aprPct: Number(document.getElementById('aprPct').value),
        maxDays: Number(document.getElementById('maxDays').value)
      }
    });

  } 
  // =======================================================================
  // MODE: JLP STRATEGY (SOL Hedged) - OLD
  // =======================================================================
  else if (isJlpMode) {
    // ... Existing JLP Logic ...
    // Copy-paste existing logic here for safety
    const solPminUsd = pmin * denomUsd;
    const solPmaxUsd = pmax * denomUsd;
    const solP0Usd   = p0   * denomUsd;
    const jlpInputVal = Number(document.getElementById('jlpUsd').value);
    const jlpUsdLive = (jlpInputVal > 0) ? jlpInputVal : (solP0Usd * 0.5); 
    if(jlpInputVal <= 0 && jlpUsdLive > 0) document.getElementById('jlpUsd').value = jlpUsdLive.toFixed(3);
    const getJlpPrice = (solPrice) => {
       if(solP0Usd <= 0) return 0;
       return jlpUsdLive * (0.5 * (solPrice / solP0Usd) + 0.5);
    };
    const jlpPmin = getJlpPrice(solPminUsd);
    const jlpPmax = getJlpPrice(solPmaxUsd);
    const jlpP0   = jlpUsdLive;
    const ratioPmin = solPminUsd / getJlpPrice(solPminUsd);
    const ratioPmax = solPmaxUsd / getJlpPrice(solPmaxUsd);
    const ratioP0   = solP0Usd / jlpUsdLive;
    const usdPortfolio = (portfolioSize * denomUsd);
    const usdCurrentE  = (currentE * denomUsd); 

    strategies.push({
      title: `JLP Strategy A: JLP / USDC (Targets scaled 2x for SOL Exposure)`,
      id: 'jlp1',
      params: {
        pmin: jlpPmin, pmax: jlpPmax, p0: jlpP0, stepPct,
        portfolioSize: usdPortfolio * 0.5,
        currentE: usdCurrentE * 0.5,
        targetMinPct: targetMinPct * 2,
        targetMaxPct: targetMaxPct * 2,
        denomSymbol: 'USDC', denomUsd: 1, assetSymbol: 'JLP',
        scaleMode: document.getElementById('scaleMode').value,
        aprPct: Number(document.getElementById('aprPct').value),
        maxDays: Number(document.getElementById('maxDays').value)
      }
    });
    
    strategies.push({
      title: `JLP Strategy B: SOL / JLP (Ratio Exposure)`,
      id: 'jlp2',
      params: {
        pmin: ratioPmin, pmax: ratioPmax, p0: ratioP0, stepPct,
        portfolioSize: (usdPortfolio * 0.5) / jlpUsdLive,
        currentE: (usdCurrentE * 0.5) / jlpUsdLive,
        targetMinPct: targetMinPct * 2, 
        targetMaxPct: targetMaxPct * 2,
        denomSymbol: 'JLP', denomUsd: jlpUsdLive, assetSymbol: 'SOL',
        scaleMode: document.getElementById('scaleMode').value,
        aprPct: Number(document.getElementById('aprPct').value),
        maxDays: Number(document.getElementById('maxDays').value)
      }
    });

  } else {
    // ---------------------------------------------------------
    // MODE: STANDARD / DUAL
    // ---------------------------------------------------------
    const capitalRatio = isDual ? 0.5 : 1.0;
    
    // LP 1: Primary
    strategies.push({
      title: isDual ? `LP 1: ${assetSymbol} / ${denomSymbol} (50% Allocation)` : 'Schedule',
      id: 'lp1',
      params: {
        pmin, pmax, p0, stepPct,
        portfolioSize: portfolioSize * capitalRatio,
        currentE: currentE * capitalRatio,
        targetMinPct, targetMaxPct,
        denomSymbol, denomUsd, assetSymbol,
        scaleMode: document.getElementById('scaleMode').value,
        aprPct: Number(document.getElementById('aprPct').value),
        maxDays: Number(document.getElementById('maxDays').value)
      }
    });

    // LP 2: Secondary (USD) -- Only if Dual
    if(isDual) {
      const usdPmin = pmin * denomUsd;
      const usdPmax = pmax * denomUsd;
      const usdP0   = p0   * denomUsd;
      const usdPortfolio = (portfolioSize * 0.5) * denomUsd;
      const usdCurrentE  = (currentE * 0.5) * denomUsd;

      strategies.push({
        title: `LP 2: ${assetSymbol} / USD (50% Allocation - Converted)`,
        id: 'lp2',
        params: {
          pmin: usdPmin, pmax: usdPmax, p0: usdP0, stepPct,
          portfolioSize: usdPortfolio,
          currentE: usdCurrentE,
          targetMinPct, targetMaxPct,
          denomSymbol: 'USD', denomUsd: 1, assetSymbol,
          scaleMode: document.getElementById('scaleMode').value,
          aprPct: Number(document.getElementById('aprPct').value),
          maxDays: Number(document.getElementById('maxDays').value)
        }
      });
    }
  }

  // 3. Calc All First
  strategies.forEach(s => {
    try {
      s.data = calculateStrategy(s.params);
    } catch(e) {
      console.error("Strategy Gen Error", e);
    }
  });

  // 4. Render Logic based on Mode
  if (isQuadMode) {
     // Render Reference
     renderLPSection(container, strategies[0].title, strategies[0].data, strategies[0].params.denomSymbol, strategies[0].params.denomUsd, strategies[0].params.assetSymbol, strategies[0].id);
     
     // Render Aggregate Table Immediately After
     renderQuadAggregateTable(container, strategies);
     
     // Render Q1, Q2, Q3, Q4
     for(let i=1; i<strategies.length; i++) {
       const s = strategies[i];
       renderLPSection(container, s.title, s.data, s.params.denomSymbol, s.params.denomUsd, s.params.assetSymbol, s.id);
     }
  } else {
     // Standard Render Loop
     strategies.forEach(s => {
       renderLPSection(container, s.title, s.data, s.params.denomSymbol, s.params.denomUsd, s.params.assetSymbol, s.id);
     });
  }
  
  // Update Global Targets Visuals
  const capitalRatio = (isDual || isJlpMode) ? 0.5 : (isQuadMode ? 0.25 : 1.0);
  const tMinEl = document.getElementById('targetMin');
  const tMaxEl = document.getElementById('targetMax');
  const tMinVal = (portfolioSize * capitalRatio) * targetMinPct / 100;
  const tMaxVal = (portfolioSize * capitalRatio) * targetMaxPct / 100;
  if (tMinEl) tMinEl.value = isFinite(tMinVal) ? tMinVal : 0;
  if (tMaxEl) tMaxEl.value = isFinite(tMaxVal) ? tMaxVal : 0;
}

// Global Copy Helper
window.copyTable = function(lpId) {
  const el = document.querySelector(`#section_${lpId} table`);
  if(!el) return;
  const range = document.createRange();
  range.selectNode(el);
  window.getSelection().removeAllRanges();
  window.getSelection().addRange(range);
  document.execCommand('copy');
  window.getSelection().removeAllRanges();
  alert('Table copied to clipboard');
};

document.getElementById('btn').addEventListener('click', generate);
document.getElementById('btnClear').addEventListener('click', () => {
  document.getElementById('resultsContainer').innerHTML = '';
});

// Init
(function(){
  const assetSel = document.getElementById('assetSelect');
  const denomSel = document.getElementById('denomSelect');
  const p0El = document.getElementById('p0');
  const denomUsdEl = document.getElementById('denomUsd');
  
  const dual = document.getElementById('dualLpMode');
  const jlp = document.getElementById('jlpStrategyMode');
  const quad = document.getElementById('quadLpMode');
  
  // Mutual exclusion
  dual.addEventListener('change', function(){ if(this.checked) { jlp.checked=false; quad.checked=false; } });
  jlp.addEventListener('change', function(){ if(this.checked) { dual.checked=false; quad.checked=false; } });
  quad.addEventListener('change', function(){ if(this.checked) { dual.checked=false; jlp.checked=false; } });

  if (assetSel) {
    assetSel.addEventListener('change', () => {
      updateAltPriceSummary();
      loadAssetConfig(assetSel.value);
    });
  }

  if (denomSel) {
    denomSel.addEventListener('change', () => {
      updateDenomLabels(denomSel.value);
      const currentAsset = assetSel ? assetSel.value : '';
      autoFetchPrices(currentAsset, denomSel.value);
    });
  }

  [p0El, denomUsdEl].forEach(e => e && e.addEventListener('change', updateAltPriceSummary));
  [p0El, denomUsdEl].forEach(e => e && e.addEventListener('input', updateAltPriceSummary));
  
  loadAssetList();
  if (denomSel) autoFetchPrices('', denomSel.value);
  updateAltPriceSummary();
})();
</script>
</body>
</html>
