<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CL LP Exposure Planner — Denom Asset Notional, Pmin/Pmax vs Denom</title>
<style>
  :root {
    --bg:#0b0f14; --card:#101620; --ink:#e8eef6; --muted:#9fb1c7;
    --accent:#5bb0ff; --good:#17c964; --bad:#ff5d5d; --warn:#ffc857;
    --highlight:#334255;
  }
  * { box-sizing:border-box; }
  body {
    margin:0; font:13px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;
    background:var(--bg); color:var(--ink);
  }
  header {
    padding:16px 18px; border-bottom:1px solid #17202d;
    position:sticky; top:0;
    background:linear-gradient(180deg,#0b0f14,#0b0f14f2 70%,transparent);
    z-index:5;
  }
  h1 { margin:0; font-size:15px; letter-spacing:.3px; font-weight:600; }
  .wrap { padding:16px 18px 36px; max-width:2000px; margin:0 auto; }
  .grid { display:grid; grid-template-columns:1.15fr 1fr; gap:14px; align-items:start; }
  .card {
    background:var(--card); border:1px solid #17202d; border-radius:16px;
    padding:14px; box-shadow:0 4px 24px rgba(0,0,0,.25);
  }
  .card h2 { margin:0 0 8px; font-size:13px; font-weight:600; color:var(--ink); }
  label { display:block; color:var(--muted); font-size:11px; margin:6px 0 3px; }
  input[type=number], select {
    width:100%; padding:8px 10px; border:1px solid #233142;
    border-radius:10px; background:#0c121a; color:var(--ink); outline:none;
    -webkit-appearance: none;
    -moz-appearance: textfield;
  }
  input[readonly] { background: var(--highlight); color: var(--accent); }
  .row { display:grid; grid-template-columns:repeat(3,1fr); gap:8px; }
  .row4 { display:grid; grid-template-columns:repeat(4,1fr); gap:8px; }
  .btns { display:flex; gap:8px; margin-top:12px; }
  button {
    padding:8px 10px; border:1px solid #223146; background:#0e1621;
    color:var(--ink); border-radius:12px; cursor:pointer; transition:.15s ease;
  }
  button.primary {
    background:linear-gradient(180deg,#1b2c43,#142133); border-color:#2d4666;
  }
  button.secondary {
    background: #1a2a3d; border-color: #2d4666; color: #a7c4e6;
  }
  button.secondary:hover {
    background: #23364d;
  }
  .muted { color:var(--muted); font-size:11px; }
  .pill {
    display:inline-block; padding:3px 7px; border-radius:999px;
    border:1px solid #26415f; background:#0f1723;
    font-size:10px; color:#a7c4e6;
  }
  table {
    width:100%; border-collapse:separate; border-spacing:0;
    min-width:1600px; table-layout:auto;
  }
  th, td {
    padding:6px 8px; border-bottom:1px solid #1a2433;
    text-align:right; white-space:nowrap;
  }
  th {
    position:sticky; top:0; background:#0f1622; z-index:2;
    font-weight:600; color:#b9cbe0; white-space:normal; line-height:1.2;
  }
  th:first-child, td:first-child {
    text-align:left; position:sticky; left:0;
    background:linear-gradient(90deg,#0f1622,#0f1622cc); z-index:1;
  }
  .sticky-r {
    position:sticky; right:0;
    background:linear-gradient(270deg,#0f1622,#0f1622cc);
    z-index:4; border-left:1px solid #1a2433;
  }
  .scroll { overflow:auto; border:1px solid #17202d; border-radius:14px; max-height:60vh; }
  .footnote { margin-top:8px; font-size:11px; color:#95a9c2; }
  .kpis {
    display:grid; grid-template-columns:repeat(3,1fr);
    gap:8px; margin-top:8px;
  }
  .kpi {
    padding:10px; border-radius:14px; border:1px solid #1a2a3d;
    background:#0e1622;
  }
  .kpi b { display:block; font-size:11px; color:#a6bdd9; margin-bottom:3px; }
  .kpi div { font-size:15px; font-weight:600; }
  .tag {
    display:inline-block; font-size:10px; padding:2px 6px;
    border-radius:999px; border:1px solid #284d6f; background:#0d1a27;
  }
  .tag.hold { border-color:#2a6f4d; background:#0d2017; }
  .tag.source { border-color:#6f2a2a; background:#27100f; }
</style>
</head>
<body>
<header>
  <h1>CL LP Exposure Planner — Quote Asset Notional (Pmin/Pmax vs chosen denom asset, targets as % of denom portfolio)</h1>
</header>

<div class="wrap">
  <div class="grid">
    <!-- LEFT: inputs -->
    <div class="card">
      <h2>Inputs
        <span class="pill" style="float:right; background:var(--good); border-color:#1c693b;">
          Live Sheets & CoinGecko PRO
        </span>
      </h2>

      <!-- Asset selection linked to "Google Sheet" -->
      <div class="row4" style="margin-top:6px; grid-template-columns:1fr 1fr 2fr;">
        <div>
          <label>Alt asset (Select to load config)</label>
          <select id="assetSelect">
            <option value="">– Select asset –</option>
            <!-- Options populated by JS from Google Apps Script -->
          </select>
        </div>
        <div>
          <label>Denominated asset</label>
          <select id="denomSelect">
            <option value="BTC" selected>BTC</option>
            <option value="ETH">ETH</option>
            <option value="SOL">SOL</option>
            <option value="BNB">BNB</option>
          </select>
        </div>
        <div>
          <label><span class="denomLabelShort">BTC</span> price (<span class="denomLabelShort">BTC</span>/USD) - Auto-Fetched</label>
          <input type="number" id="denomUsd" step="0.01" value="60000">
        </div>
      </div>
      <div class="footnote" id="sheetStatus" style="margin-bottom:8px; color:var(--warn);">
        Loading asset list from Google Sheet...
      </div>


      <!-- Prices in ALT/Denom -->
      <div class="row">
        <div>
          <label>Price Min (Pmin, ALT/denom)</label>
          <input type="number" id="pmin" step="0.00000001" value="0.00010000">
        </div>
        <div>
          <label>Price Max (Pmax, ALT/denom)</label>
          <input type="number" id="pmax" step="0.00000001" value="0.00035000">
        </div>
        <div>
          <label>Current Price (P₀, ALT/denom)
             <span style="color:var(--good); font-weight:bold; margin-left:4px;" id="p0LiveTag"></span>
          </label>
          <input type="number" id="p0" step="0.00000001" value="0.00020800">
        </div>
      </div>

      <div class="row4" style="margin-top:6px; grid-template-columns:1fr 3fr;">
        <div>
          <label>Current ALT price (derived)</label>
          <div class="muted" id="altPriceSummary">Set P₀ and denom price to see ALT/USD.</div>
        </div>
        <div></div>
      </div>


      <!-- Portfolio + target % -->
      <div class="row4" style="margin-top:6px;">
        <div>
          <label>Portfolio size (<span class="denomLabelShort">BTC</span>)</label>
          <input type="number" id="portfolioSize" step="0.0001" value="0">
        </div>
        <div>
          <label>Target net exposure @ Pmin (% of portfolio)</label>
          <input type="number" id="targetMinPct" step="0.01" value="0">
        </div>
        <div>
          <label>Target net exposure @ Pmax (% of portfolio)</label>
          <input type="number" id="targetMaxPct" step="0.01" value="-100">
        </div>
        <div></div>
      </div>

      <!-- Interval + current E + auto targets -->
      <div class="row4" style="margin-top:6px;">
        <div>
          <label>Interval size (%)</label>
          <input type="number" id="intervalPct" step="0.01" value="1">
        </div>
        <div>
          <label>Current Net Exposure (<span class="denomLabelShort">BTC</span>)
            <span class="muted">(ALT value + short value, before LP)</span>
          </label>
          <input type="number" id="currentE" step="0.0001" value="0">
        </div>
        <div>
          <label>Target net exposure @ Pmin (<span class="denomLabelShort">BTC</span>, auto)</label>
          <input type="number" id="targetMin" step="0.0001" value="0" readonly>
        </div>
        <div>
          <label>Target net exposure @ Pmax (<span class="denomLabelShort">BTC</span>, auto)</label>
          <input type="number" id="targetMax" step="0.0001" value="0" readonly>
        </div>
      </div>

      <!-- Misc config -->
      <div class="row4" style="margin-top:6px;">
        <div>
          <label>Precision decimals</label>
          <input type="number" id="dec" step="1" value="4">
        </div>
        <div>
          <label>Assume current exposure scales with price?</label>
          <select id="scaleMode">
            <option value="scale">Scale linearly with price (default)</option>
            <option value="noscale">Do not scale current exposure</option>
          </select>
        </div>
        <div>
          <label>Cap rows (optional)</label>
          <input type="number" id="capRows" step="1" placeholder="">
        </div>
        <div>
          <label>Show zero-only rows?</label>
          <select id="showZeros">
            <option value="hide">Hide</option>
            <option value="show">Show</option>
          </select>
        </div>
      </div>

      <!-- APR -->
      <div class="row4" style="margin-top:6px;">
        <div>
          <label>LP APR on total capital (%)</label>
          <input type="number" id="aprPct" step="0.01" value="20">
        </div>
        <div>
          <label>Max days in-range to simulate</label>
          <input type="number" id="maxDays" step="1" value="365">
        </div>
        <div>
          <span class="muted">
            APR accrues on total LP capital between Pmin–Pmax while price stays in range.
            Capital is measured in the chosen denom asset; USD view is via denom/USD input.
          </span>
        </div>
      </div>

      <div class="btns">
        <button class="primary" id="btn">Generate Schedules</button>
        <button class="secondary" id="btnCopy" style="display:flex; align-items:center; gap:5px;">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
          Copy Schedule
        </button>
        <button id="btnClear">Clear Tables</button>
      </div>

      <div class="footnote">
        <span class="pill">Math notes</span>
        Uses Uniswap v3 square‑root mapping with <b>p = ALT/denom</b>. All deposits &amp; targets are in
        the chosen denom asset notional. For band [p<sub>a</sub>, p<sub>b</sub>] with p<sub>a</sub>&lt;p<sub>b</sub>:
        a denom‑only deposit below converts at p<sub>a</sub> to ALT worth denom × √(p<sub>a</sub>/p<sub>b</sub>). Above, an ALT‑only deposit converts back to denom at
        p<sub>b</sub> with factor √(p<sub>b</sub>/p<sub>a</sub>). Below schedule solves
        Σ denom<sub>i</sub>·√(p<sub>a</sub>/p<sub>b</sub>) = (target<sub>pmin</sub> − current<sub>@pmin</sub>).
        Above schedule solves Σ denom<sub>i</sub>·√(p<sub>b</sub>/p<sub>a</sub>) =
        (current<sub>@pmax</sub> − target<sub>pmax</sub>). USD values are derived via denom/USD.
      </div>
    </div>

    <!-- RIGHT: KPIs -->
    <div class="card">
      <h2>Quick KPIs</h2>
      <div class="kpis">
        <div class="kpi">
          <b>Below total to deploy (<span class="denomLabelShort">BTC</span> / USD)</b>
          <div id="kBelow">–</div>
        </div>
        <div class="kpi">
          <b>Above total to deploy (<span class="denomLabelShort">BTC</span> / USD @ P₀)</b>
          <div id="kAbove">–</div>
        </div>
        <div class="kpi">
          <b>Intervals (down / up)</b>
          <div id="kN">–</div>
        </div>
        <div class="kpi">
          <b>Residual @ Pmin (<span class="denomLabelShort">BTC</span> / USD)</b>
          <div id="kResMin">–</div>
        </div>
        <div class="kpi">
          <b>Residual @ Pmax (<span class="denomLabelShort">BTC</span> / USD)</b>
          <div id="kResMax">–</div>
        </div>
      </div>
      <div class="kpis" style="margin-top:8px;">
        <div class="kpi">
          <b>Above funded from holdings (@P₀, <span class="denomLabelShort">BTC</span> / USD)</b>
          <div id="kAboveFromHoldings">–</div>
        </div>
        <div class="kpi">
          <b>Above to buy + short (@P₀, <span class="denomLabelShort">BTC</span> / USD)</b>
          <div id="kAboveToSource">–</div>
        </div>
        <div class="kpi">
          <b>Buy+Short starts at price ≥</b>
          <div id="kStartPx">–</div>
        </div>
      </div>
      <div class="footnote">
        Rule: if you’re net long and set <b>target @ Pmax = 0</b>, the above schedule uses
        <i>only current holdings</i> (no buy+short). If you set a <b>negative target @ Pmax</b>,
        the schedule <i>first uses holdings</i> and then continues with buy+short to reach the
        target. Allocation across bands is linear (same ALT denom notional per band).
      </div>
    </div>

    <!-- Sum range -->
    <div class="card">
      <h2>Sum a Price Range</h2>
      <div class="row" style="grid-template-columns:1fr 1fr 1fr;">
        <div>
          <label>Start price (ALT/denom)</label>
          <input type="number" id="sumStart" step="0.00000001" placeholder="e.g., 0.00020000">
        </div>
        <div>
          <label>End price (ALT/denom)</label>
          <input type="number" id="sumEnd" step="0.00000001" placeholder="e.g., 0.00022000">
        </div>
        <div style="display:flex;align-items:flex-end;gap:8px;">
          <button id="btnSum">Sum Range</button>
          <span class="muted">Sums bands whose boundary is within [start, end].</span>
        </div>
      </div>
      <div class="kpis" style="margin-top:8px;">
        <div class="kpi">
          <b>Total deploy (<span class="denomLabelShort">BTC</span> / USD, below)</b>
          <div id="sDeployBelow">–</div>
        </div>
        <div class="kpi">
          <b>Total value @ pₐ → ALT (<span class="denomLabelShort">BTC</span> / USD)</b>
          <div id="sValToAlt">–</div>
        </div>
        <div class="kpi">
          <b>ALT units from below</b>
          <div id="sAltUnitsBelow">–</div>
        </div>
      </div>
      <div class="kpis" style="margin-top:8px;">
        <div class="kpi">
          <b>Total deploy (<span class="denomLabelShort">BTC</span> / USD, above)</b>
          <div id="sDeployAbove">–</div>
        </div>
        <div class="kpi">
          <b>ALT units to sell (above)</b>
          <div id="sAltUnitsAbove">–</div>
        </div>
        <div class="kpi">
          <b>Total sale @ pᵦ (<span class="denomLabelShort">BTC</span> / USD in)</b>
          <div id="sSale">–</div>
        </div>
      </div>
      <div class="kpis" style="margin-top:8px;">
        <div class="kpi">
          <b>Net ALT units (below − above)</b>
          <div id="sAltUnitsNet">–</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Schedule table -->
  <div class="card" style="margin-top:14px;">
    <h2>Schedule — Per % Band Below and Above P₀ (denom asset notional)</h2>
    <div class="scroll">
      <table id="tbl">
        <thead>
          <tr>
            <th>Band</th>
            <th>p<sub>a</sub> (ALT/denom)</th>
            <th>p<sub>b</sub> (ALT/denom)</th>
            <th>Type</th>
            <th>√(p<sub>a</sub>/p<sub>b</sub>)</th>
            <th>√(p<sub>b</sub>/p<sub>a</sub>)</th>
            <th>Deploy (<span class="denomLabelShort">BTC</span> / USD, below)</th>
            <th>Value @ p<sub>a</sub> (to ALT, <span class="denomLabelShort">BTC</span> / USD)</th>
            <th>Deploy ALT value @ P₀ (<span class="assetLabelShort">ALT</span> / USD, above)</th>
            <th>Source (above)</th>
            <th>Sale @ p<sub>b</sub> (<span class="denomLabelShort">BTC</span> / USD out)</th>
            <th>ALT units to sell</th>
            <th>Net exposure @ boundary (<span class="denomLabelShort">BTC</span> / USD)</th>
            <th>PnL @ boundary (<span class="denomLabelShort">BTC</span> / USD vs no-LP)</th>
            <th class="sticky-r">Days to breakeven (APR)</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="footnote">
      “Source (above)” shows whether the ALT notional for that band is taken from
      <span class="tag hold">Holdings</span> or requires
      <span class="tag source">Buy+Short</span>.
      “ALT units to sell” = Deploy ALT notional ÷ band start price (pₐ).
      Net exposure columns are in the chosen denom asset notional, displayed as denom / USD.
    </div>
  </div>

  <!-- APR analytics -->
  <div class="card" style="margin-top:14px;">
    <h2>APR &amp; PnL Analytics</h2>
    <div class="row4">
      <div>
        <label>Price point for PnL vs days</label>
        <select id="priceSelect">
          <option value="">– Select after generating schedule –</option>
        </select>
      </div>
      <div>
        <span class="muted">
          Uses LP APR %, total capital between Pmin–Pmax, assumes price stays in range.
          PnL is in the chosen denom asset; USD comes from denom/USD.
        </span>
      </div>
    </div>
    <div style="margin-top:12px;">
      <div class="footnote">
        Line chart: PnL over days (including APR) for a selected boundary price (denom notional).
      </div>
      <canvas id="pnlDaysChart" height="200"></canvas>
    </div>
    <div style="margin-top:18px;">
      <div class="footnote">
        Bar chart: breakeven days vs boundary price for all negative‑PnL rows.
      </div>
      <canvas id="breakevenByPriceChart" height="200"></canvas>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
// --- START: GOOGLE APPS SCRIPT URL ---
const APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbzqG0z2v6nZZZpuhGVYHR28R71jpKl4psheB3bsMQ1bj2Hc4-590l-7Xgj8LUG6cFryMw/exec';
// --- END: GOOGLE APPS SCRIPT URL ---

// Expanded CoinGecko ID map
// IMPORTANT: Add new assets here for auto-price fetching to work
const COINGECKO_IDS = {
  BTC: 'bitcoin',
  ETH: 'ethereum',
  SOL: 'solana',
  BNB: 'binancecoin',
  ARB: 'arbitrum',
  OP:  'optimism',
  TIA: 'celestia',
  MATIC: 'matic-network',
  LINK: 'chainlink',
  AVAX: 'avalanche-2',
  DOGE: 'dogecoin',
  ADA: 'cardano',
  XRP: 'ripple',
  LDO: 'lido-dao',
  UNI: 'uniswap',
  ASTER: 'aster-2' // CORRECTED: ASTER mapping to the 'aster-2' API ID
};

function fmt(x, d){
  if(!isFinite(x)) return '–';
  const s = Number(x).toFixed(d);
  return Number(s).toLocaleString(undefined,{
    minimumFractionDigits:d,
    maximumFractionDigits:d
  });
}

function fmtDenom(x, denomDecimals, denomUsd, denomSymbol){
  if(!isFinite(x)) return '–';
  const denomStr = fmt(x, denomDecimals) + ' ' + denomSymbol;
  if(!(denomUsd > 0)) return denomStr;
  const usdStr = fmt(x * denomUsd, 2) + ' USD';
  return denomStr + ' / ' + usdStr;
}

function buildBands(pmin, pmax, p0, stepPct){
  const down = [], up = [];
  let p = p0;
  while(p > pmin){
    const pb = p;
    const pa = Math.max(pmin, pb * (1 - stepPct/100));
    down.push({pa, pb, type:'Below'});
    if(pa === pmin) break;
    p = pa;
  }
  p = p0;
  while(p < pmax){
    const pa = p;
    const pb = Math.min(pmax, pa * (1 + stepPct/100));
    up.push({pa, pb, type:'Above'});
    if(pb === pmax) break;
    p = pb;
  }
  return {down, up};
}

function updateDenomLabels(sym){
  const s = sym || 'BTC';
  document.querySelectorAll('.denomLabelShort').forEach(el => { el.textContent = s; });
}

function updateAssetLabels(sym){
  const s = sym || 'ALT';
  document.querySelectorAll('.assetLabelShort').forEach(el => { el.textContent = s; });
}

function updateAltPriceSummary(){
  const p0El = document.getElementById('p0');
  const denomUsdEl = document.getElementById('denomUsd');
  const out = document.getElementById('altPriceSummary');
  if(!p0El || !denomUsdEl || !out) return;
  const p0 = Number(p0El.value || 0);
  const denomUsd = Number(denomUsdEl.value || 0);
  const denomSym = (document.getElementById('denomSelect')?.value || 'BTC').toUpperCase();
  const assetSym = (document.getElementById('assetSelect')?.value || 'ALT').toUpperCase();
  if(!(p0 > 0 && denomUsd > 0)){
    out.textContent = 'Set P₀ and ' + denomSym + '/USD to see ' + assetSym + '/USD.';
    return;
  }
  const altUsd = p0 * denomUsd;
  out.textContent = assetSym + ' = ' + fmt(p0, 8) + ' ' + denomSym +
                    ' ≈ ' + fmt(altUsd, 4) + ' USD';
}

// Fetch current prices for BOTH Asset and Denom, then calculate P0
async function autoFetchPrices(assetSym, denomSym){
  const p0LiveTag = document.getElementById('p0LiveTag');
  if(p0LiveTag) p0LiveTag.textContent = '';

  const assetId = COINGECKO_IDS[(assetSym || '').toUpperCase()];
  const denomId = COINGECKO_IDS[(denomSym || '').toUpperCase()];

  if(!denomId){
    console.log('No denom ID found for auto-fetch');
    return;
  }

  // We always need denom price
  let idsToFetch = denomId;
  if(assetId) idsToFetch += ',' + assetId;

  try {
    // --- FIX START: Handle Preview/Local Environment ---
    // Relative URLs like '/api/price' fail in blob/file previews because there is no backend.
    if (window.location.protocol === 'file:' || window.location.protocol === 'blob:') {
      console.log("Environment check: Vercel API is not available in local preview (blob/file). Skipping price fetch.");
      const sheetStatus = document.getElementById('sheetStatus');
      if(sheetStatus) sheetStatus.innerHTML += ' <span style="color:var(--warn)">(Live prices require Vercel deployment)</span>';
      return;
    }
    // --- FIX END ---

    // CHANGED: Call local Vercel API proxy instead of external CoinGecko API directly
    const url = `/api/price?ids=${encodeURIComponent(idsToFetch)}&vs_currencies=usd`;
    
    const res = await fetch(url);
    if(!res.ok) throw new Error('HTTP ' + res.status);
    const data = await res.json();

    const denomPriceUsd = data[denomId]?.usd;
    
    // 1. Update Denom Price
    if(denomPriceUsd){
      const denomUsdEl = document.getElementById('denomUsd');
      if(denomUsdEl) denomUsdEl.value = denomPriceUsd;
    }

    // 2. Calculate P0 if possible
    if(assetId && data[assetId]?.usd && denomPriceUsd){
      const assetPriceUsd = data[assetId].usd;
      const derivedP0 = assetPriceUsd / denomPriceUsd;
      
      const p0El = document.getElementById('p0');
      if(p0El){
        p0El.value = derivedP0.toFixed(8);
        if(p0LiveTag) p0LiveTag.textContent = '(Live)';
        console.log(`Auto-calculated P0 for ${assetSym}/${denomSym}: ${derivedP0}`);
      }
    }

    updateAltPriceSummary();
    // Re-run generation with new prices
    generate();

  } catch(err){
    console.error('Error fetching prices:', err);
  }
}

async function loadAssetList(){
  const sel = document.getElementById('assetSelect');
  const statusEl = document.getElementById('sheetStatus');
  if(!sel || !statusEl || APPS_SCRIPT_URL.includes('YOUR_APPS_SCRIPT')) {
    statusEl.innerHTML = '<span style="color:var(--bad)">ERROR:</span> Check APPS_SCRIPT_URL.';
    return;
  }

  statusEl.textContent = 'Loading asset list from Google Sheet...';
  sel.innerHTML = '<option value="">– Select asset –</option>';
  
  try{
    const res = await fetch(APPS_SCRIPT_URL);
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    
    if(data.error){
       throw new Error(data.error);
    }
    
    if(data.assets && Array.isArray(data.assets)){
      data.assets.forEach(sym => {
        if(sym && String(sym).trim() !== ''){
          const opt = document.createElement('option');
          opt.value = String(sym).trim();
          opt.textContent = String(sym).trim();
          sel.appendChild(opt);
        }
      });
      statusEl.textContent = `Successfully loaded ${data.assets.length} assets from Google Sheet.`;
    } else {
      throw new Error('Invalid data structure returned from Google Sheet.');
    }
  }catch(err){
    console.error('Error loading asset list', err);
    statusEl.innerHTML = `<span style="color:var(--bad)">ERROR:</span> Failed to load asset list. (${err.message})`;
  }
}

async function loadAssetConfig(symbol){
  if(!symbol) return;
  
  const statusEl = document.getElementById('sheetStatus');
  statusEl.textContent = `Loading config for ${symbol} from Google Sheet...`;

  try{
    const url = `${APPS_SCRIPT_URL}?symbol=${encodeURIComponent(symbol)}`;
    const res = await fetch(url);
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();

    if(data.error) throw new Error(data.error);

    // --- Fill Inputs from Sheet ---
    // Note: We intentionally skip P0 from sheet if we are going to fetch it live,
    // but we set it initially as a fallback.
    if(typeof data.pmin === 'number') document.getElementById('pmin').value = data.pmin;
    if(typeof data.pmax === 'number') document.getElementById('pmax').value = data.pmax;
    if(typeof data.p0   === 'number') document.getElementById('p0').value   = data.p0;

    if(typeof data.currentE === 'number')
      document.getElementById('currentE').value = data.currentE;

    if(typeof data.portfolioSize === 'number')
      document.getElementById('portfolioSize').value = data.portfolioSize;

    if(typeof data.targetMinPct === 'number')
      document.getElementById('targetMinPct').value = data.targetMinPct;

    if(typeof data.targetMaxPct === 'number')
      document.getElementById('targetMaxPct').value = data.targetMaxPct;

    let denomSym = 'BTC';
    if(data.denomAsset){
      const dSel = document.getElementById('denomSelect');
      if(dSel){
        dSel.value = data.denomAsset;
        updateDenomLabels(data.denomAsset);
        denomSym = data.denomAsset;
      }
    }
    
    // --- AUTO PRICE FETCH ---
    // This will override the sheet's P0 with the live calculation (Asset/Denom)
    await autoFetchPrices(symbol, denomSym);

    updateAltPriceSummary();
    generate();
    statusEl.textContent = `Config for ${symbol} loaded. Prices auto-updated.`;

  }catch(err){
    console.error('Error loading config', err);
    statusEl.innerHTML = `<span style="color:var(--bad)">ERROR:</span> Failed to load ${symbol}. (${err.message})`;
  }
}

function generate(){
  const dec = parseInt(document.getElementById('dec').value || '4', 10);

  const pmin = Number(document.getElementById('pmin').value);
  const pmax = Number(document.getElementById('pmax').value);
  const p0   = Number(document.getElementById('p0').value);
  const stepPct = Number(document.getElementById('intervalPct').value);

  const denomSymbol = (document.getElementById('denomSelect')?.value || 'BTC').toUpperCase();
  const denomUsd = Number(document.getElementById('denomUsd')?.value || 0);

  const assetSymbol = (document.getElementById('assetSelect')?.value || 'ALT').toUpperCase();

  updateDenomLabels(denomSymbol);
  updateAssetLabels(assetSymbol);
  updateAltPriceSummary();

  const portfolioSize = Number(document.getElementById('portfolioSize')?.value || 0);
  const targetMinPct  = Number(document.getElementById('targetMinPct')?.value || 0);
  const targetMaxPct  = Number(document.getElementById('targetMaxPct')?.value || 0);

  const targetMin = portfolioSize * targetMinPct / 100;
  const targetMax = portfolioSize * targetMaxPct / 100;

  const tMinEl = document.getElementById('targetMin');
  const tMaxEl = document.getElementById('targetMax');
  if (tMinEl) tMinEl.value = isFinite(targetMin) ? targetMin : 0;
  if (tMaxEl) tMaxEl.value = isFinite(targetMax) ? targetMax : 0;

  const currentE = Number(document.getElementById('currentE').value || 0);
  const capRows = parseInt(document.getElementById('capRows').value || '0', 10) || null;

  if(!(pmin>0 && pmax>pmin && p0>0 && p0>=pmin && p0<=pmax)){
    return; // invalid inputs, just stop silently
  }

  const bands = buildBands(pmin,pmax,p0,stepPct);
  const Ndown = bands.down.length, Nup = bands.up.length;

  const scaleFactorAt = (px) =>
    (document.getElementById('scaleMode').value === 'scale' ? (px/p0) : 1);

  const currentAtMin = currentE * scaleFactorAt(pmin);
  const needMinDelta = (targetMin - currentAtMin);
  let sumRdown = 0;
  for(const b of bands.down){
    b.r_down = Math.sqrt(b.pa / b.pb);
    sumRdown += b.r_down;
  }
  const perUsdBelow = sumRdown>0 ? (needMinDelta / sumRdown) : 0;

  for(const b of bands.up){ b.r_up = Math.sqrt(b.pb / b.pa); }
  const sumRup = bands.up.reduce((s,b)=> s + b.r_up, 0);

  const currentAtMax = currentE * scaleFactorAt(pmax);
  const needMoreNegativeAtMax = currentAtMax - targetMax;
  const perAltUsdNeeded = sumRup>0 ? (needMoreNegativeAtMax / sumRup) : 0;
  let aboveTotalNeeded = perAltUsdNeeded * Nup;

  let holdingsAvail   = Math.max(currentE, 0);
  let buyShortAllowed = (targetMax < 0);

  let aboveTotalScheduled = aboveTotalNeeded;
  let holdingsUsed        = 0;
  let toBuyShort          = 0;

  if (Nup === 0) aboveTotalScheduled = 0;

  if (currentE > 0 && targetMax === 0){
    aboveTotalScheduled = Math.min(aboveTotalNeeded, holdingsAvail);
    holdingsUsed        = aboveTotalScheduled;
    toBuyShort          = 0;
  }else{
    holdingsUsed = Math.min(holdingsAvail, aboveTotalNeeded);
    toBuyShort   = Math.max(0, aboveTotalNeeded - holdingsUsed);
    if(!buyShortAllowed){
      aboveTotalScheduled = holdingsUsed;
      toBuyShort          = 0;
    }
  }

  const perAltUsdSchedule = Nup>0 ? (aboveTotalScheduled / Nup) : 0;

  const aprPct   = Number(document.getElementById('aprPct')?.value || 0);
  const maxDays  = parseInt(document.getElementById('maxDays')?.value || '365', 10);
  const dailyRate = aprPct > 0 ? (aprPct / 100 / 365) : 0;

  const totalCapitalAPR = (perUsdBelow * Ndown) + aboveTotalScheduled;

  const tbody    = document.querySelector('#tbl tbody');
  const rowsData = [];
  tbody.innerHTML = '';

  let belowTotal = 0, aboveTotal = 0;
  const ordered  = [...bands.down, ...bands.up];

  let cumBelowValue = 0;
  let cumAboveSale  = 0;

  let holdingsRemaining = holdingsUsed;
  let startBuyShortPx   = null;

  let idx = 0;
  for(const b of ordered){
    const isDown = (b.type === 'Below');
    const rdown  = isDown ? b.r_down : 0;
    const rup    = !isDown ? b.r_up : 0;

    let deployUSD = 0;
    let valueAtPa = 0;
    let deployAltUsd = 0;
    let saleAtPb  = 0;
    let sourceTag = '';

    const boundaryPx = isDown ? b.pa : b.pb;

    if(isDown){
      deployUSD  = perUsdBelow;
      valueAtPa  = deployUSD * rdown;
      belowTotal += deployUSD;
      cumBelowValue += valueAtPa;
    }else{
      if(aboveTotal < aboveTotalScheduled - 1e-12){
        deployAltUsd = Math.min(perAltUsdSchedule, aboveTotalScheduled - aboveTotal);
        aboveTotal  += deployAltUsd;

        if(holdingsRemaining > 0){
          const useHold = Math.min(deployAltUsd, holdingsRemaining);
          holdingsRemaining -= useHold;
          sourceTag = '<span class="tag hold">Holdings</span>';
          if(deployAltUsd - useHold > 1e-12){
            sourceTag = '<span class="tag hold">Holdings</span> + <span class="tag source">Buy+Short</span>';
            if(startBuyShortPx === null) startBuyShortPx = b.pa;
          }
        }else{
          sourceTag = '<span class="tag source">Buy+Short</span>';
          if(startBuyShortPx === null) startBuyShortPx = b.pa;
        }

        saleAtPb     = deployAltUsd * rup;
        cumAboveSale += saleAtPb;
      }
    }

    const baseE         = currentE * scaleFactorAt(boundaryPx);
    const netAtBoundary = isDown ? (baseE + cumBelowValue) : (baseE - cumAboveSale);

    const altUnitsBelow = 0;
    const altUnitsAbove = (!isDown && deployAltUsd>0) ? (deployAltUsd / b.pa) : 0;

    const pnlAtBoundary = netAtBoundary - baseE;

    let daysToBE = null;
    if(dailyRate > 0 && totalCapitalAPR > 0 && pnlAtBoundary < 0){
      const ratio = 1 - (pnlAtBoundary / totalCapitalAPR);
      if(ratio > 1){
        daysToBE = Math.log(ratio) / Math.log(1 + dailyRate);
      }
    }

    const row = [
      `${isDown ? '↓ Below' : '↑ Above'} ${++idx}`,
      b.pa, b.pb, b.type,
      isDown ? rdown : 0,
      !isDown ? rup : 0,
      deployUSD, valueAtPa, deployAltUsd, sourceTag, saleAtPb,
      altUnitsAbove,
      netAtBoundary,
      pnlAtBoundary,
      daysToBE
    ];

    rowsData.push({
      pa:b.pa,
      pb:b.pb,
      type:b.type,
      deployUSD,
      valueAtPa,
      deployAltUsd,
      saleAtPb,
      altUnitsBelow,
      altUnitsAbove,
      boundaryPx,
      pnlAtBoundary,
      daysToBE
    });

    const showZeros = document.getElementById('showZeros').value === 'show';
    const nonzero   = (Math.abs(deployUSD) + Math.abs(deployAltUsd)) > 1e-12;
    if(showZeros || nonzero){
      const tr = document.createElement('tr');
      row.forEach((v,i)=>{
        const td = document.createElement('td');
        if(i===0 || i===3){
          td.textContent = v;
          td.style.textAlign = 'left';
        }else if(i===9){
          td.innerHTML = v || '';
          td.style.textAlign = 'left';
        }else{
          if(i===8){
             // Special formatting for "Deploy ALT value @ P0" (Above)
             // Display as Alt Amount + USD
             const altUnits = (p0 > 0) ? (v / p0) : 0;
             const usdVal = v * denomUsd;
             td.textContent = fmt(altUnits, 6) + ' ' + assetSymbol + ' / ' + fmt(usdVal, 2) + ' USD';
          }
          else if(i===6 || i===7 || i===10 || i===12 || i===13){
            td.textContent = fmtDenom(v, 6, denomUsd, denomSymbol);
          }else{
            td.textContent = fmt(v, (i<=5)?6:dec);
          }
        }
        if(i===14) td.classList.add('sticky-r');
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    }
    if(capRows && idx>=capRows) break;
  }

  document.getElementById('kN').textContent = `${Ndown} ↓ / ${Nup} ↑`;
  document.getElementById('kBelow').textContent = fmtDenom(belowTotal, 6, denomUsd, denomSymbol);
  document.getElementById('kAbove').textContent = fmtDenom(aboveTotalScheduled, 6, denomUsd, denomSymbol);

  const netAtPmin = (currentE * scaleFactorAt(pmin)) +
    bands.down.reduce((s,b)=> s + perUsdBelow * Math.sqrt(b.pa/b.pb), 0);
  const netAtPmax = (currentE * scaleFactorAt(pmax)) -
    bands.up.reduce((s,b)=> s + perAltUsdSchedule * Math.sqrt(b.pb/b.pa), 0);

  const resMin = netAtPmin - targetMin;
  const resMax = netAtPmax - targetMax;

  document.getElementById('kResMin').textContent = fmtDenom(resMin, 6, denomUsd, denomSymbol);
  document.getElementById('kResMax').textContent = fmtDenom(resMax, 6, denomUsd, denomSymbol);

  window._rowsData = rowsData;

  function sumRange(){
    const d      = parseInt(document.getElementById('dec').value || '4', 10);
    const sStart = document.getElementById('sumStart').value;
    const sEnd   = document.getElementById('sumEnd').value;
    if(!sStart || !sEnd){ console.error('Enter start and end prices.'); return; }
    let a = Number(sStart), b = Number(sEnd);
    if(!(a>0 && b>0)){ console.error('Enter valid start/end prices.'); return; }
    if(a>b){ const t=a; a=b; b=t; }

    const inRange = (row) => {
      const boundary = (row.type==='Below') ? row.pa : row.pb;
      return boundary >= a - 1e-12 && boundary <= b + 1e-12;
    };

    let sDeployBelow=0, sValToAlt=0, sAltUnitsBelow=0;
    let sDeployAbove=0, sAltUnitsAbove=0, sSale=0;

    for(const r of (window._rowsData || [])){
      if(!inRange(r)) continue;
      if(r.type==='Below'){
        sDeployBelow += r.deployUSD;
        sValToAlt    += r.valueAtPa;
      }else{
        sDeployAbove   += r.deployAltUsd;
        sAltUnitsAbove += (r.altUnitsAbove || 0);
        sSale          += r.saleAtPb;
      }
    }

    const fmtUnits = (x) => Number(x).toLocaleString(
      undefined,
      {minimumFractionDigits:d, maximumFractionDigits:d}
    );

    document.getElementById('sDeployBelow').textContent   = fmtDenom(sDeployBelow, 6, denomUsd, denomSymbol);
    document.getElementById('sValToAlt').textContent      = fmtDenom(sValToAlt, 6, denomUsd, denomSymbol);
    document.getElementById('sAltUnitsBelow').textContent = fmtUnits(sAltUnitsBelow);

    document.getElementById('sDeployAbove').textContent   = fmtDenom(sDeployAbove, 6, denomUsd, denomSymbol);
    document.getElementById('sAltUnitsAbove').textContent = fmtUnits(sAltUnitsAbove);
    document.getElementById('sSale').textContent          = fmtDenom(sSale, 6, denomUsd, denomSymbol);

    document.getElementById('sAltUnitsNet').textContent =
      fmtUnits(sAltUnitsBelow - sAltUnitsAbove);
  }

  const btnSumEl = document.getElementById('btnSum');
  if(btnSumEl && !btnSumEl._boundSumRange){
    btnSumEl.addEventListener('click', sumRange);
    btnSumEl._boundSumRange = true;
  }

  const priceSelect = document.getElementById('priceSelect');
  const chartMeta = {
    rows: rowsData,
    negRows: rowsData.filter(r =>
      typeof r.pnlAtBoundary === 'number' && r.pnlAtBoundary < 0),
    totalCapitalAPR,
    dailyRate,
    maxDays,
    denomSymbol,
    denomUsd
  };
  window._aprChartMeta = chartMeta;

  if(priceSelect){
    priceSelect.innerHTML = '';
    if(chartMeta.negRows.length === 0 || dailyRate <= 0 || totalCapitalAPR <= 0){
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = 'No negative PnL rows or APR = 0';
      priceSelect.appendChild(opt);
    }else{
      chartMeta.negRows.forEach((r, idx) => {
        const opt  = document.createElement('option');
        opt.value  = String(idx);
        const side = (r.type === 'Below') ? '↓' : '↑';
        const px   = (r.type === 'Below' ? r.pa : r.pb);
        opt.textContent =
          `${side} boundary ${px.toFixed(dec)} — PnL₀ ${fmtDenom(r.pnlAtBoundary, 6, denomUsd, denomSymbol)}`;
        priceSelect.appendChild(opt);
      });
      priceSelect.value = '0';
    }
  }

  if(typeof Chart !== 'undefined' &&
     chartMeta.negRows.length > 0 && dailyRate > 0 && totalCapitalAPR > 0){
    buildAprCharts(dec);
  }else{
    destroyAprCharts();
  }

  document.getElementById('kAboveFromHoldings').textContent =
    fmtDenom(holdingsUsed, 6, denomUsd, denomSymbol);
  document.getElementById('kAboveToSource').textContent =
    fmtDenom(toBuyShort && buyShortAllowed ? toBuyShort : 0, 6, denomUsd, denomSymbol);
  document.getElementById('kStartPx').textContent =
    startBuyShortPx ? fmt(startBuyShortPx, 8) + ' ALT/' + denomSymbol : '—';

  window._calcRows = {down: bands.down, up: bands.up};
  window._alloc    = {perUsdBelow, perAltUsdSchedule};
}

let pnlDaysChart = null;
let breakevenByPriceChart = null;

function destroyAprCharts(){
  if(pnlDaysChart){ pnlDaysChart.destroy(); pnlDaysChart = null; }
  if(breakevenByPriceChart){ breakevenByPriceChart.destroy(); breakevenByPriceChart = null; }
}

function buildAprCharts(dec){
  if(!window._aprChartMeta) return;
  const meta = window._aprChartMeta;
  const { negRows, totalCapitalAPR, dailyRate, maxDays, denomSymbol } = meta;
  if(!negRows || negRows.length === 0 || !dailyRate || !totalCapitalAPR) return;

  const priceSelect = document.getElementById('priceSelect');
  let idx = 0;
  if(priceSelect && priceSelect.value){
    idx = parseInt(priceSelect.value, 10);
    if(isNaN(idx) || idx<0 || idx>=negRows.length) idx = 0;
  }

  const row = negRows[idx];
  const pnl0 = row ? row.pnlAtBoundary : 0;

  const days = [];
  const pnlSeries = [];
  for(let d=0; d<=maxDays; d++){
    days.push(d);
    const aprPnL = totalCapitalAPR * (Math.pow(1 + dailyRate, d) - 1);
    pnlSeries.push(pnl0 + aprPnL);
  }

  const ctx1 = document.getElementById('pnlDaysChart');
  if(ctx1){
    if(pnlDaysChart) pnlDaysChart.destroy();
    pnlDaysChart = new Chart(ctx1.getContext('2d'), {
      type:'line',
      data:{
        labels:days,
        datasets:[{
          label:'PnL vs days (' + denomSymbol + ', selected boundary)',
          data:pnlSeries
        }]
      },
      options:{
        responsive:true,
        plugins:{
          legend:{display:true},
          title:{display:false}
        },
        scales:{
          x:{title:{display:true,text:'Days in-range'}},
          y:{title:{display:true,text:'PnL (' + denomSymbol + ')'}}
        }
      }
    });
  }

  const labels = [];
  const beData = [];
  meta.negRows.forEach(r => {
    const px = (r.type === 'Below' ? r.pa : r.pb);
    labels.push(px.toFixed(dec));
    beData.push(r.daysToBE != null ? r.daysToBE : null);
  });

  const ctx2 = document.getElementById('breakevenByPriceChart');
  if(ctx2){
    if(breakevenByPriceChart) breakevenByPriceChart.destroy();
    breakevenByPriceChart = new Chart(ctx2.getContext('2d'), {
      type:'bar',
      data:{
        labels,
        datasets:[{
          label:'Days to breakeven (APR)',
          data:beData
        }]
      },
      options:{
        responsive:true,
        plugins:{
          legend:{display:true},
          title:{display:false}
        },
        scales:{
          x:{title:{display:true,text:'Boundary price (ALT/denom)'}},
          y:{title:{display:true,text:'Days to breakeven'}}
        }
      }
    });
  }

  const sel = document.getElementById('priceSelect');
  if(sel && !sel._aprBound){
    sel.addEventListener('change', () => buildAprCharts(dec));
    sel._aprBound = true;
  }
}

document.getElementById('btn').addEventListener('click', generate);
document.getElementById('btnClear').addEventListener('click', () => {
  document.querySelector('#tbl tbody').innerHTML = '';
  ['kBelow','kAbove','kN','kResMin','kResMax',
   'kAboveFromHoldings','kAboveToSource','kStartPx'].forEach(id => {
    const el = document.getElementById(id);
    if(el) el.textContent = '–';
  });
  destroyAprCharts();
});

// Copy function
document.getElementById('btnCopy').addEventListener('click', () => {
  const rows = [];
  // Header
  const header = [];
  document.querySelectorAll('#tbl thead th').forEach(th => {
    header.push(th.innerText.replace(/\n/g, ' '));
  });
  rows.push(header.join('\t'));

  // Body
  document.querySelectorAll('#tbl tbody tr').forEach(tr => {
    const row = [];
    tr.querySelectorAll('td').forEach(td => {
      // Clean up any HTML tags or newlines
      let text = td.innerText.replace(/(\r\n|\n|\r)/gm, " ").trim();
      row.push(text);
    });
    rows.push(row.join('\t'));
  });

  const tsv = rows.join('\n');
  
  const textArea = document.createElement("textarea");
  textArea.value = tsv;
  document.body.appendChild(textArea);
  textArea.select();
  try {
    document.execCommand('copy');
    const btn = document.getElementById('btnCopy');
    const originalText = btn.innerHTML;
    btn.innerHTML = 'Copied!';
    setTimeout(() => btn.innerHTML = originalText, 2000);
  } catch (err) {
    console.error('Unable to copy', err);
  }
  document.body.removeChild(textArea);
});

// Immediately load asset list from the Google Sheet
loadAssetList();

(function(){
  const assetSel = document.getElementById('assetSelect');
  const denomSel = document.getElementById('denomSelect'); // Define this earlier

  if(assetSel){
    assetSel.addEventListener('change', () => {
      updateAltPriceSummary();
      loadAssetConfig(assetSel.value);
    });
  }
  
  if(denomSel){
    denomSel.addEventListener('change', () => {
      updateDenomLabels(denomSel.value);
      // Fix ReferenceError: call autoFetchPrices instead of autoFetchDenomPrice
      const currentAsset = assetSel ? assetSel.value : '';
      autoFetchPrices(currentAsset, denomSel.value); 
    });
  }
  
  // Set initial denom label
  updateDenomLabels(denomSel ? denomSel.value : 'BTC');
  
  // Fix ReferenceError: Initial fetch
  // We can just fetch the denom price initially if no asset is selected yet.
  if(denomSel) {
     autoFetchPrices('', denomSel.value);
  }

  const p0El = document.getElementById('p0');
  const denomUsdEl = document.getElementById('denomUsd');
  if(p0El){
    p0El.addEventListener('input', updateAltPriceSummary);
  }
  if(denomUsdEl){
    denomUsdEl.addEventListener('input', updateAltPriceSummary);
  }
  
  // Update summary on load
  updateAltPriceSummary();
})();
</script>
</body>
</html>
