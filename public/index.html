<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>CL LP Exposure Planner</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#111824;
      --panel2:#0f1622;
      --text:#e6edf3;
      --muted:#93a4b8;
      --accent:#4ea1ff;
      --good:#38d996;
      --bad:#ff5c5c;
      --warn:#ffcc66;
      --border:rgba(255,255,255,.08);
      --shadow:0 10px 30px rgba(0,0,0,.35);
      --radius:14px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    body{
      margin:0;
      background: radial-gradient(1200px 600px at 50% 0%, rgba(78,161,255,.14), transparent 60%),
                  radial-gradient(800px 500px at 80% 20%, rgba(56,217,150,.12), transparent 55%),
                  var(--bg);
      color:var(--text);
      font-family:var(--font);
    }
    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:16px 18px;
      border-bottom:1px solid var(--border);
      position:sticky;
      top:0;
      backdrop-filter: blur(10px);
      background: rgba(11,15,20,.7);
      z-index:5;
    }
    header .title{
      font-weight:700;
      letter-spacing:.2px;
    }
    header .subtitle{
      font-size:12px;
      color:var(--muted);
      margin-top:2px;
    }
    .tabs{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .tab{
      border:1px solid var(--border);
      background: rgba(255,255,255,.03);
      color:var(--muted);
      padding:8px 10px;
      border-radius:10px;
      cursor:pointer;
      font-weight:600;
      font-size:12px;
    }
    .tab.active{
      color:var(--text);
      border-color: rgba(78,161,255,.45);
      box-shadow: 0 0 0 2px rgba(78,161,255,.08) inset;
    }
    .wrap{
      padding:22px 18px 30px;
      max-width: 1320px;
      margin: 0 auto;
    }
    .panel{
      background: linear-gradient(180deg, rgba(17,24,36,.9), rgba(15,22,34,.9));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:18px;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:16px;
    }
    .panel h2{
      font-size:13px;
      margin:0 0 10px;
      color:var(--text);
      letter-spacing:.3px;
    }
    label{
      display:block;
      font-size:11px;
      color:var(--muted);
      margin-bottom:6px;
    }
    input, select, button{
      font-family: var(--font);
    }
    input, select{
      width:100%;
      box-sizing:border-box;
      padding:9px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      color:var(--text);
      outline:none;
    }
    input:focus, select:focus{
      border-color: rgba(78,161,255,.6);
      box-shadow: 0 0 0 3px rgba(78,161,255,.12);
    }
    .row3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:8px;
    }
    .row4{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr 1fr;
      gap:8px;
    }
    .controls{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:12px;
      align-items:center;
    }
    button{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      color: var(--text);
      padding:10px 12px;
      border-radius:10px;
      cursor:pointer;
      font-weight:700;
      font-size:12px;
    }
    button.primary{
      border-color: rgba(78,161,255,.5);
      box-shadow: 0 0 0 2px rgba(78,161,255,.08) inset;
    }
    button.good{
      border-color: rgba(56,217,150,.5);
      box-shadow: 0 0 0 2px rgba(56,217,150,.08) inset;
      color: var(--good);
    }
    button.warn{
      border-color: rgba(255,204,102,.5);
      box-shadow: 0 0 0 2px rgba(255,204,102,.08) inset;
      color: var(--warn);
    }
    button.bad{
      border-color: rgba(255,92,92,.5);
      box-shadow: 0 0 0 2px rgba(255,92,92,.08) inset;
      color: var(--bad);
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      font-size:11px;
      padding:5px 9px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      color:var(--muted);
    }
    .pill.good{ color: var(--good); border-color: rgba(56,217,150,.45); }
    .pill.bad{ color: var(--bad); border-color: rgba(255,92,92,.45); }
    .pill.warn{ color: var(--warn); border-color: rgba(255,204,102,.45); }
    .muted{ color: var(--muted); }
    .small{ font-size:11px; color: var(--muted); }
    .split{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
      margin-bottom:10px;
    }
    .results{
      margin-top:18px;
    }
    table{
      width:100%;
      border-collapse:collapse;
      overflow:hidden;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.02);
    }
    th, td{
      font-size:12px;
      padding:10px 10px;
      border-bottom:1px solid rgba(255,255,255,.06);
      text-align:right;
      white-space:nowrap;
    }
    th{
      text-align:right;
      color: var(--muted);
      font-weight:700;
      background: rgba(255,255,255,.03);
    }
    th:first-child, td:first-child{ text-align:left; }
    .kpiGrid{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:10px;
      margin: 12px 0 10px;
    }
    .kpi{
      padding:10px;
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      background: rgba(255,255,255,.02);
    }
    .kpi .label{ font-size:10px; color: var(--muted); }
    .kpi .value{ font-size:13px; font-weight:800; margin-top:4px; }
    .sectionTitle{
      margin: 22px 0 10px;
      font-weight:800;
      letter-spacing:.2px;
      font-size:13px;
      color: var(--accent);
    }
    .divider{
      height:1px;
      background: rgba(255,255,255,.08);
      margin: 16px 0;
    }
    .right{
      text-align:right;
    }
    .hidden{ display:none; }
    .checkboxRow{
      display:flex; gap:14px; align-items:center; flex-wrap:wrap;
      margin-top:10px;
    }
    .checkboxRow label{
      margin:0;
      font-size:12px;
      color:var(--text);
      display:flex;
      align-items:center;
      gap:8px;
      cursor:pointer;
    }
    .checkboxRow input[type="checkbox"]{
      width:16px; height:16px;
      accent-color: var(--accent);
    }
    .note{
      font-size:10px;
      color:var(--muted);
      margin-top:6px;
      line-height:1.35;
    }
    .panelTopNote{
      font-size:11px;
      color:var(--muted);
      margin-top:-4px;
      margin-bottom:14px;
    }
  </style>
</head>
<body>
<header>
  <div>
    <div class="title">CL LP Exposure Planner</div>
    <div class="subtitle">Single LP Planner & Cross-Pair Optimizer UI — with Sheets + price auto-load and denom-aware math.</div>
  </div>
  <div class="tabs">
    <button class="tab active" id="tabSingle">Single LP Planner</button>
    <button class="tab" id="tabCross">Cross-Pair Optimizer</button>
  </div>
</header>

<div class="wrap">

  <!-- SINGLE LP PANEL -->
  <div id="panelSingle" class="panel">
    <div class="grid2">
      <div>
        <div class="split">
          <h2>INPUTS</h2>
          <div style="display:flex; gap:8px; align-items:center;">
            <span class="pill" id="sheetStatus">Sheets: –</span>
            <span class="pill" id="priceStatus">Prices: –</span>
          </div>
        </div>

        <div class="row3">
          <div>
            <label>Alt asset (Select to load config)</label>
            <select id="assetSelect"></select>
          </div>

          <div>
            <label>Denominated asset</label>
            <select id="denomSelect">
              <option value="BTC">BTC</option>
              <option value="ETH">ETH</option>
              <option value="SOL">SOL</option>
              <option value="BNB">BNB</option>
              <option value="HYPE">HYPE</option>
              <option value="USD">USD</option>
            </select>
          </div>

          <div style="display:flex; flex-direction:column; justify-content:flex-end;">
            <div class="pill good" style="justify-content:center;">Live Sheets & CoinGecko PRO</div>
          </div>
        </div>

        <div class="row3" style="margin-top:6px;">
          <div>
            <label>Alt Price (USD)</label>
            <input type="number" id="altUsd" step="0.01" value="0">
          </div>
          <div>
            <label><span class="denomLabelShort">BTC</span> Price (USD)</label>
            <input type="number" id="denomUsd" step="0.01" value="0">
          </div>
          <div>
            <label>JLP Price (USD, for JLP Mode)</label>
            <input type="number" id="jlpUsd" step="0.01" value="0">
          </div>
        </div>

        <div class="row3" style="margin-top:6px;">
          <div>
            <label>Price Min (Pmin, ALT/denom)</label>
            <input type="number" id="pmin" step="0.00000001" value="0">
          </div>
          <div>
            <label>Price Max (Pmax, ALT/denom)</label>
            <input type="number" id="pmax" step="0.00000001" value="0">
          </div>
          <div>
            <label>Current Price P₀ (ALT/denom) <span class="muted">(Calculated)</span></label>
            <input type="number" id="p0" step="0.00000001" value="0">
          </div>
        </div>

        <div class="row3" style="margin-top:6px;">
          <div>
            <label>Total Portfolio size (<span class="denomLabelShort">BTC</span>)</label>
            <input type="number" id="portfolioSize" step="0.0001" value="0">
          </div>
          <div>
            <label>Target net exposure @ Pmin (% of portfolio)</label>
            <input type="number" id="targetMinPct" step="0.01" value="50">
          </div>
          <div>
            <label>Target net exposure @ Pmax (% of portfolio)</label>
            <input type="number" id="targetMaxPct" step="0.01" value="150">
          </div>
        </div>

<div class="row5" style="display:grid; grid-template-columns:repeat(5,1fr); gap:8px; margin-top:6px;">
          <div>
            <label>Interval size (%)</label>
            <input type="number" id="intervalPct" step="0.01" value="1">
          </div>

          <div style="position:relative;">
            <label>Current Net Exposure (<span class="denomLabelShort">BTC</span>)
              <span class="muted">(ALT + short, before LP)</span>
            </label>
            <div style="display:flex; gap:4px;">
              <input type="number" id="currentE" step="0.0001" value="0" style="flex:1;">
              <span id="fetchIndicator" style="display:none; color:var(--accent); font-size:10px; align-self:center;">Updating...</span>
            </div>
            <div id="fetchStatus" style="font-size:10px; color:var(--warn); margin-top:2px; height:14px;"></div>
          </div>

          <div>
            <label>Target @ P₀ (<span class="denomLabelShort">BTC</span>, auto)</label>
            <input type="number" id="targetP0" step="0.0001" value="0" readonly>
            <div id="targetP0Delta" style="font-size:10px; color:var(--muted); margin-top:2px; height:14px;"></div>
          </div>

          <div>
            <label>Target @ Pmin (<span class="denomLabelShort">BTC</span>, auto)</label>
            <input type="number" id="targetMin" step="0.0001" value="0" readonly>
          </div>

          <div>
            <label>Target @ Pmax (<span class="denomLabelShort">BTC</span>, auto)</label>
            <input type="number" id="targetMax" step="0.0001" value="0" readonly>
          </div>
        </div>

        <div class="row4" style="margin-top:6px;">
          <div style="position:relative;">
            <label>Denom Current Net Exposure (<span class="denomLabelShort">BTC</span>, auto)</label>
            <input type="number" id="denomCurrentE" step="0.0001" value="0" readonly>
            <div id="denomFetchStatus" style="font-size:10px; color:var(--muted); margin-top:2px; height:14px;"></div>
          </div>
          <div>
            <label>Denom Target Exposure (<span class="denomLabelShort">BTC</span>, manual)</label>
            <input type="number" id="denomTargetE" step="0.0001" value="0">
          </div>
          <div>
            <label>Denom Δ vs Target (<span class="denomLabelShort">BTC</span>)</label>
            <input type="number" id="denomDeltaE" step="0.0001" value="0" readonly>
          </div>
          <div>
            <label>Denom budget for Below (max spend) (<span class="denomLabelShort">BTC</span>)</label>
            <input type="number" id="denomBudget" step="0.0001" value="0" readonly>
          </div>
        </div>

        <div class="row4" style="margin-top:6px;">
          <div>
            <label>Precision decimals</label>
            <input type="number" id="precision" step="1" value="6">
          </div>
          <div>
            <label>Distribution Mode</label>
            <select id="distMode">
              <option value="uniform">Equal Units (Linear)</option>
              <option value="univ3">UniV3 Liquidity</option>
            </select>
          </div>
          <div>
            <label>Show zero-only rows?</label>
            <select id="hideZeroRows">
              <option value="hide">Hide</option>
              <option value="show">Show</option>
            </select>
          </div>
          <div>
            <label>Assume current exposure scales with price?</label>
            <select id="scaleMode">
              <option value="scale">Scale linearly with price (default)</option>
              <option value="fixed">Keep current exposure fixed</option>
            </select>
          </div>
        </div>

        <div class="row4" style="margin-top:6px;">
          <div>
            <label>Active % (Below)</label>
            <input type="number" id="activeBelowPct" step="0.01" value="10">
          </div>
          <div>
            <label>Active % (Above)</label>
            <input type="number" id="activeAbovePct" step="0.01" value="10">
          </div>
          <div>
            <label>APR on Active Capital (%)</label>
            <input type="number" id="aprPct" step="0.01" value="20">
          </div>
          <div>
            <label>Max days in-range (for analytics)</label>
            <input type="number" id="maxDays" step="1" value="365">
          </div>
        </div>

        <div class="checkboxRow">
          <label><input type="checkbox" id="dualLpMode"> Dual LP</label>
          <div style="display:flex; align-items:center; gap:8px;">
            <span class="small">LP2 range mult</span>
            <input type="number" id="dualMult" step="0.1" value="1.0" style="width:80px;">
            <span class="small muted">x</span>
          </div>
          <label><input type="checkbox" id="jlpStrategyMode"> JLP Mode (Hedged)</label>
          <label><input type="checkbox" id="tripleLpMode"> Triple Split (3-Way)</label>
        </div>

        <div class="controls">
          <button class="primary" id="btnGen">Generate Schedules</button>
          <button id="btnExposure">Generate Exposure</button>
          <button class="good" id="btnPnl">Generate PnL</button>
          <button class="warn" id="btnAutoExp">Auto-load Exposure</button>
          <button class="warn" id="btnAutoPx">Auto-load Prices</button>
          <button class="bad" id="btnClear">Clear Outputs</button>
        </div>

        <div class="note">
          Tip: hit <b>Auto-load Prices</b> then <b>Auto-load Exposure</b> then generate. Dual mode creates two tables.
        </div>
      </div>

      <div>
        <div class="split">
          <h2>OUTPUTS</h2>
          <div style="display:flex; gap:8px; align-items:center;">
            <span class="pill" id="bandsPill">0 bands</span>
            <span class="pill" id="modePill">Uniform</span>
          </div>
        </div>
        <div id="resultsContainer">
          <div class="pill" style="width:100%; justify-content:center;">No schedules generated yet</div>
        </div>
      </div>
    </div>
  </div>

  <!-- CROSS PAIR PANEL -->
  <div id="panelCross" class="panel hidden">
    <div class="split">
      <h2>Cross-Pair Optimizer</h2>
      <div style="display:flex; gap:8px;">
        <button class="primary" id="btnCaptureA">Capture Base (A)</button>
        <button class="primary" id="btnCaptureB">Capture Quote (B)</button>
        <button class="bad" id="btnClearCross">Clear Tables</button>
      </div>
    </div>

    <div class="panelTopNote">
      Capture two schedules (A and B). This optimizer prints a combined view for managing cross-pair exposure. (Display-first, strategy knobs later.)
    </div>

    <div class="grid2">
      <div>
        <div class="sectionTitle">Captured Base (A)</div>
        <div id="captureA" class="pill" style="width:100%; justify-content:center;">None</div>
        <div class="divider"></div>
        <div class="sectionTitle">Captured Quote (B)</div>
        <div id="captureB" class="pill" style="width:100%; justify-content:center;">None</div>
      </div>

      <div>
        <div class="sectionTitle">Optimizer Output</div>
        <div id="crossOut" class="pill" style="width:100%; justify-content:center;">Capture both A and B to compute.</div>
        <div id="crossTableWrap" style="margin-top:12px;"></div>
      </div>
    </div>
  </div>

</div>

<script>
/**
 * Google Apps Script endpoint that reads LP_Parameters and returns:
 * { symbol, denomAsset, pmin, pmax, targetMinPct, targetMaxPct }
 * and can optionally include price data.
 */
const APPS_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbzD3Xh8ZC0FzqJ1MxwB1m0g-7fJtX5G7y7qjvXQ9e1tq1Y0WcZL8dYfWm9rYx2xjQ/exec";

// CoinGecko IDs map (extend as needed)
const COINGECKO_IDS = {
  BTC: 'bitcoin',
  ETH: 'ethereum',
  SOL: 'solana',
  BNB: 'binancecoin',
  USDC: 'usd-coin',
  USDT: 'tether',
  USD: 'usd',
  JLP: 'jupiter-perpetuals-liquidity-provider-token',
  ASTER: 'aster',
  USELESS: 'useless',
  XPL: 'plasma',
  HYPE: 'hyperliquid',
  "4": '4-2',
  GIGGLE: 'giggle-fund',
  MET: 'metacade',
  CAKE: 'pancakeswap-token',
  SUI: 'sui',
  XRP: 'ripple',
  APT: 'aptos',
  ZEC: 'zcash',
  VIRTUAL: 'virtual-protocol',
  AERO: 'aerodrome-finance',
  ADA: 'cardano',
  AVAX: 'avalanche-2',
  ORE: 'ore',
  SEI: 'sei-network',
  BANK: 'bankless-dao',
  META: 'meta-2',
  AVICI: 'avici',
  CLANKER: 'tokenbot-2',
  AVNT: 'avantis',
  PUMP: 'pump-fun',
  LINEA: 'linea',
  S: 'sonic',
  ZORA: 'zora',
  MMT: 'mmt',
  HIPPO: 'hippopotamus',
  FET: 'fetch-ai',
  CC: 'cc',
  TAO: 'bittensor',
  PIGGY: 'piggy',
  ZEN: 'horizen',
  ARB: 'arbitrum',
  UNI: 'uniswap',
  DOGE: 'dogecoin'
};

function fmt(n, d=2){
  if(n === null || n === undefined || isNaN(n)) return '–';
  return Number(n).toLocaleString(undefined, {maximumFractionDigits:d, minimumFractionDigits:d});
}

function updateDenomLabels(denomSym){
  const els = document.querySelectorAll('.denomLabelShort');
  els.forEach(el => el.textContent = denomSym.toUpperCase());
}

function showPanel(which){
  const pSingle = document.getElementById('panelSingle');
  const pCross = document.getElementById('panelCross');
  const tSingle = document.getElementById('tabSingle');
  const tCross = document.getElementById('tabCross');
  if(which === 'single'){
    pSingle.classList.remove('hidden');
    pCross.classList.add('hidden');
    tSingle.classList.add('active');
    tCross.classList.remove('active');
  }else{
    pSingle.classList.add('hidden');
    pCross.classList.remove('hidden');
    tSingle.classList.remove('active');
    tCross.classList.add('active');
  }
}

document.getElementById('tabSingle').addEventListener('click', () => showPanel('single'));
document.getElementById('tabCross').addEventListener('click', () => showPanel('cross'));

// --- Price helpers ---
async function fetchPriceBatch(symbols){
  // Resolve to CoinGecko IDs
  const ids = symbols
    .map(s => COINGECKO_IDS[(s||'').toUpperCase()])
    .filter(Boolean)
    .join(',');
  if(!ids) return {};

  const url = `/api/price?ids=${encodeURIComponent(ids)}&vs_currencies=usd`;
  const res = await fetch(url);
  if(!res.ok) throw new Error(`Price HTTP ${res.status}`);
  const data = await res.json(); // {id:{usd:...}}
  return data;
}

async function autoFetchPrices(assetSym, denomSym){
  const priceEl = document.getElementById('priceStatus');
  priceEl.textContent = 'Prices: loading...';
  priceEl.className = 'pill';
  try{
    const a = (assetSym||'').toUpperCase();
    const d = (denomSym||'').toUpperCase();
    const list = [];
    if(a) list.push(a);
    if(d) list.push(d);
    // also JLP
    list.push('JLP');

    const data = await fetchPriceBatch(list);

    const altId = COINGECKO_IDS[a];
    const denomId = COINGECKO_IDS[d];
    const jlpId = COINGECKO_IDS['JLP'];

    const altUsd = (altId && data[altId] && data[altId].usd) ? data[altId].usd : 0;
    const denomUsd = (denomId && data[denomId] && data[denomId].usd) ? data[denomId].usd : (d === 'USD' ? 1 : 0);
    const jlpUsd = (jlpId && data[jlpId] && data[jlpId].usd) ? data[jlpId].usd : 0;

    if(altUsd) document.getElementById('altUsd').value = Number(altUsd).toFixed(2);
    if(denomUsd) document.getElementById('denomUsd').value = Number(denomUsd).toFixed(2);
    if(jlpUsd) document.getElementById('jlpUsd').value = Number(jlpUsd).toFixed(2);

    // recompute p0
    updateP0FromUsd();

    priceEl.textContent = 'Prices: OK';
    priceEl.classList.add('good');
    triggerAutoFetch();
  }catch(err){
    console.error(err);
    priceEl.textContent = `Prices: failed`;
    priceEl.classList.add('bad');
  }
}

function updateP0FromUsd(){
  const altUsd = Number(document.getElementById('altUsd').value) || 0;
  const denomUsd = Number(document.getElementById('denomUsd').value) || 0;
  if(altUsd > 0 && denomUsd > 0){
    const p0 = altUsd / denomUsd;
    document.getElementById('p0').value = p0.toFixed(9);
  }
}

function updateUsdFromP0(){
  const p0 = Number(document.getElementById('p0').value) || 0;
  const denomUsd = Number(document.getElementById('denomUsd').value) || 0;
  if(p0 > 0 && denomUsd > 0){
    document.getElementById('altUsd').value = (p0 * denomUsd).toFixed(2);
  }
}

// --- Exposure helpers ---
let fetchTimeout = null;
function triggerAutoFetch(){
  // Debounce so if user changes denom selection / prices, we re-fetch exposure once.
  if(fetchTimeout) clearTimeout(fetchTimeout);
  fetchTimeout = setTimeout(() => fetchLiveExposure(), 400);
}

function updateAutoTargets() {
    const portSize = Number(document.getElementById('portfolioSize')?.value) || 0;
    const minPct = Number(document.getElementById('targetMinPct')?.value) || 0;
    const maxPct = Number(document.getElementById('targetMaxPct')?.value) || 0;

    const tMin = portSize * (minPct / 100.0);
    const tMax = portSize * (maxPct / 100.0);

    const targetMinEl = document.getElementById('targetMin');
    const targetMaxEl = document.getElementById('targetMax');
    if (targetMinEl) targetMinEl.value = tMin.toFixed(4);
    if (targetMaxEl) targetMaxEl.value = tMax.toFixed(4);

    // --- NEW: Target @ P0 (current price) ---
    const targetP0El = document.getElementById('targetP0');
    const deltaEl = document.getElementById('targetP0Delta');
    if (!targetP0El) return;

    const p0 = Number(document.getElementById('p0')?.value) || 0;
    const pmin = Number(document.getElementById('pmin')?.value) || 0;
    const pmax = Number(document.getElementById('pmax')?.value) || 0;
    const mode = document.getElementById('distMode')?.value || 'uniform';
    const denomSym = (document.getElementById('denomSelect')?.value || 'BTC').toUpperCase();

    let tP0 = 0;
    if (p0 > 0 && pmin > 0 && pmax > pmin) {
        const units = getUnitsHeldAt(p0, pmin, pmax, portSize, minPct, maxPct, mode);
        tP0 = units * p0;
        targetP0El.value = tP0.toFixed(4);
    } else {
        targetP0El.value = '0';
    }

    if (deltaEl) {
        const cur = Number(document.getElementById('currentE')?.value) || 0;
        const delta = cur - tP0;
        const sign = delta >= 0 ? '+' : '';
        deltaEl.textContent = `Δ Current vs Target @P₀: ${sign}${fmt(delta, 4)} ${denomSym}`;
        deltaEl.style.color = (Math.abs(delta) < 1e-9) ? 'var(--muted)' : (delta > 0 ? 'var(--good)' : 'var(--bad)');
    }
}

function updateDenomBudget() {
    const curEl = document.getElementById('denomCurrentE');
    const tgtEl = document.getElementById('denomTargetE');
    const deltaEl = document.getElementById('denomDeltaE');
    const budgetEl = document.getElementById('denomBudget');

    if (!curEl || !tgtEl || !deltaEl || !budgetEl) return;

    const cur = Number(curEl.value) || 0;
    const tgt = Number(tgtEl.value) || 0;
    const delta = cur - tgt;

    deltaEl.value = delta.toFixed(6);
    budgetEl.value = Math.max(0, delta).toFixed(6);
}

async function fetchLiveExposure() {
  const assetSymRaw = (document.getElementById('assetSelect')?.value || '').trim();
  const denomSym = (document.getElementById('denomSelect')?.value || 'BTC').toUpperCase();
  const denomUsd = Number(document.getElementById('denomUsd')?.value || 0);

  const statusEl = document.getElementById('fetchStatus');
  const denomStatusEl = document.getElementById('denomFetchStatus');

  const currentEEl = document.getElementById('currentE');
  const denomCurrentEl = document.getElementById('denomCurrentE');

  const indEl = document.getElementById('fetchIndicator');

  if (!assetSymRaw) { if(statusEl) statusEl.textContent = ''; return; }
  if (denomUsd <= 0) return;

  if (indEl) indEl.style.display = 'block';

  try {
    const res = await fetch('/api/exposure');
    if (!res.ok) throw new Error(`Error ${res.status}`);

    const rawData = await res.json();

    // Normalize to a list of rows
    let dataList = [];
    if (Array.isArray(rawData)) {
        dataList = rawData;
    } else if (typeof rawData === 'object' && rawData !== null) {
        const keys = Object.keys(rawData);
        if (keys.length > 0 && keys.every(k => k === k.toUpperCase() && k.length < 10)) {
            dataList = keys.map(k => ({ symbol: k, ...rawData[k] }));
        } else if (Array.isArray(rawData.table_data)) dataList = rawData.table_data;
        else if (Array.isArray(rawData.data)) dataList = rawData.data;
        else if (Array.isArray(rawData.positions)) dataList = rawData.positions;
        else if (Array.isArray(rawData.result)) dataList = rawData.result;
        else dataList = [rawData];
    }

    const findRow = (symUpper) => dataList.find(p => {
        const s1 = (p.symbol || '').toUpperCase();
        const s2 = (p.ticker || '').toUpperCase();
        const s3 = (p.asset || '').toUpperCase();
        const s4 = (p.name || '').toUpperCase();
        return s1 === symUpper || s2 === symUpper || s3 === symUpper || s4 === symUpper;
    });

    // --- Numerator (ALT) current exposure ---
    const searchAsset = assetSymRaw.toUpperCase();
    const foundAsset = findRow(searchAsset);

    if (foundAsset) {
        const usdVal = Number(foundAsset.net_exposure_usd_from_base || 0);
        if (!isNaN(usdVal)) {
            const denomExposure = usdVal / denomUsd;
            if (currentEEl) currentEEl.value = denomExposure.toFixed(6);
            if (statusEl) {
                statusEl.textContent = `Auto-Loaded: $${fmt(usdVal, 0)} exposure`;
                statusEl.style.color = 'var(--good)';
            }
        } else if (statusEl) {
            statusEl.textContent = `Found ${searchAsset}, but exposure missing.`;
            statusEl.style.color = 'var(--warn)';
        }
    } else if (statusEl) {
        statusEl.textContent = `No position found for ${searchAsset}.`;
        statusEl.style.color = 'var(--muted)';
    }

    // --- Denom current exposure (for budget / targeting) ---
    if (denomCurrentEl) {
        const foundDenom = findRow(denomSym);
        if (foundDenom) {
            const usdValDenom = Number(foundDenom.net_exposure_usd_from_base || 0);
            if (!isNaN(usdValDenom)) {
                const denomExposure = usdValDenom / denomUsd;
                denomCurrentEl.value = denomExposure.toFixed(6);
                if (denomStatusEl) {
                    denomStatusEl.textContent = `Auto-Loaded: $${fmt(usdValDenom, 0)} denom exposure`;
                    denomStatusEl.style.color = 'var(--good)';
                }
            } else if (denomStatusEl) {
                denomStatusEl.textContent = `Found ${denomSym}, but exposure missing.`;
                denomStatusEl.style.color = 'var(--warn)';
            }
        } else if (denomStatusEl) {
            denomCurrentEl.value = '0';
            denomStatusEl.textContent = `No denom position found for ${denomSym}.`;
            denomStatusEl.style.color = 'var(--muted)';
        }
    }

    updateDenomBudget();
    updateAutoTargets();
    generate();

  } catch (err) {
    console.error(err);
    if (statusEl) {
        statusEl.textContent = `Fetch failed: ${err.message}`;
        statusEl.style.color = 'var(--bad)';
    }
    if (denomStatusEl) {
        denomStatusEl.textContent = `Denom fetch failed: ${err.message}`;
        denomStatusEl.style.color = 'var(--bad)';
    }
  } finally {
    if (indEl) indEl.style.display = 'none';
  }
}

// --- Schedule math ---
function buildBands(pmin, pmax, p0, stepPct){
  const down = [];
  const up = [];

  // down side: from p0 to pmin
  let pb = p0;
  let idx = 0;
  while(pb > pmin*(1+1e-12)){
    const pa = Math.max(pmin, pb*(1 - stepPct/100));
    idx += 1;
    down.push({ type:'Below', pa, pb, origIdx: idx });
    pb = pa;
    if(pa <= pmin*(1+1e-12)) break;
  }

  // up side: from p0 to pmax
  let pa = p0;
  idx = 0;
  while(pa < pmax*(1-1e-12)){
    const pb2 = Math.min(pmax, pa*(1 + stepPct/100));
    idx += 1;
    up.push({ type:'Above', pa, pb: pb2, origIdx: idx });
    pa = pb2;
    if(pb2 >= pmax*(1-1e-12)) break;
  }

  return { down, up };
}

function calculateStrategy(params, manualBands) {
  const {
    pmin, pmax, p0, stepPct,
    portfolioSize, targetMinPct, targetMaxPct, currentE,
    denomSymbol, denomUsd, assetSymbol,
    scaleMode, distMode,
    denomBudget
  } = params;

  if (!manualBands && !(pmin > 0 && pmax > pmin && p0 > 0)) return null;

  let bands = manualBands;
  if (!bands) { bands = buildBands(pmin, pmax, p0, stepPct); }

  const Ndown = bands.down.length;
  const Nup = bands.up.length;

  const targetMin = portfolioSize * (targetMinPct / 100);
  const targetMax = portfolioSize * (targetMaxPct / 100);

  // If "scale" is selected, assume the CURRENT net exposure scales linearly with price.
  // That is: currentE is measured at P0, so at Px we estimate currentE(Px)=currentE*(Px/P0).
  const scaleFactorAt = (px) => (scaleMode === 'scale' && p0 > 0) ? (px / p0) : 1;

  const currentAtMin = currentE * scaleFactorAt(pmin);
  const currentAtMax = currentE * scaleFactorAt(pmax);

  // --- Correct endpoint math ---
  // To reach a target VALUE at an endpoint, you need the right NUMBER OF UNITS,
  // because exposure at Px is Units * Px (in denom terms).
  //
  // Below side (down moves): buy units so that at Pmin we add (targetMin - currentAtMin).
  // Above side (up moves):  sell units so that at Pmax we remove (currentAtMax - targetMax).
  const needBuyValAtMin = Math.max(0, targetMin - currentAtMin);       // denom value to ADD at Pmin
  const needSellValAtMax = Math.max(0, currentAtMax - targetMax);      // denom value to REMOVE at Pmax

  const buyUnitsTarget = (pmin > 0) ? (needBuyValAtMin / pmin) : 0;    // ALT units to buy by Pmin
  let sellUnitsTarget = (pmax > 0) ? (needSellValAtMax / pmax) : 0;    // ALT units to sell by Pmax

  // If targetMax is non-negative, we don't assume you can short past your holdings.
  const allowShort = (targetMax < 0);
  const holdingsUnitsAvail = (p0 > 0) ? (Math.max(currentE, 0) / p0) : 0;
  if (!allowShort) sellUnitsTarget = Math.min(sellUnitsTarget, holdingsUnitsAvail);

  // NEW: denom budget cap for BELOW (spend) side (in denom units).
  // If denomBudget isn't provided, we treat it as unlimited.
  const budget = (typeof denomBudget === 'number' && isFinite(denomBudget)) ? Math.max(0, denomBudget) : Infinity;

  // --- BELOW allocations ---
  let buyUnits = 0;
  let totalBelowQuote = 0;     // denom spent
  let perBandQuoteBelow = 0;   // for uniform mode
  let L_Below = 0;             // for univ3 mode

  if (Ndown > 0 && buyUnitsTarget > 0) {
      if (distMode === 'univ3') {
          const termUnits = (1 / Math.sqrt(pmin)) - (1 / Math.sqrt(p0)); // positive
          if (termUnits > 0) {
              const L_raw = buyUnitsTarget / termUnits;
              const quote_raw = L_raw * (Math.sqrt(p0) - Math.sqrt(pmin)); // total denom spent across [pmin,p0]
              const scale = (quote_raw > 0 && isFinite(budget)) ? Math.min(1, budget / quote_raw) : (isFinite(budget) ? 0 : 1);
              L_Below = L_raw * scale;
              totalBelowQuote = quote_raw * scale;
              buyUnits = buyUnitsTarget * scale;
          }
      } else {
          // "Equal Units (Linear)" mode for BELOW side is implemented as equal QUOTE per band,
          // but we solve quote-per-band so that the sum of bought units hits buyUnitsTarget.
          let sumInvMid = 0;
          for (const b of bands.down) {
              const mid = Math.sqrt(b.pa * b.pb);
              if (mid > 0) sumInvMid += 1 / mid;   // units = quote * (1/mid)
          }
          if (sumInvMid > 0) {
              const qPerBand_raw = buyUnitsTarget / sumInvMid;
              const quote_raw = qPerBand_raw * Ndown;
              const scale = (quote_raw > 0 && isFinite(budget)) ? Math.min(1, budget / quote_raw) : (isFinite(budget) ? 0 : 1);
              perBandQuoteBelow = qPerBand_raw * scale;
              totalBelowQuote = quote_raw * scale;
              buyUnits = buyUnitsTarget * scale;
          }
      }
  }

  // --- ABOVE allocations ---
  let sellUnits = 0;
  let totalAboveQuote = 0;     // denom received (execution value across bands)
  let unitsPerBandAbove = 0;   // for uniform mode
  let L_Above = 0;             // for univ3 mode

  if (Nup > 0 && sellUnitsTarget > 0) {
      sellUnits = sellUnitsTarget;
      if (distMode === 'univ3') {
          const termUnits = (1 / Math.sqrt(p0)) - (1 / Math.sqrt(pmax)); // positive
          if (termUnits > 0) L_Above = sellUnits / termUnits;
      } else {
          // Equal UNITS per band on the ask side.
          unitsPerBandAbove = sellUnits / Nup;
      }
  }

  // --- Build per-band rows ---
  const rows = [];
  const ordered = [...bands.down, ...bands.up];

  ordered.forEach((b, idx) => {
      const isDown = (b.type === 'Below');

      if (isDown) {
          let quote = 0;
          if (distMode === 'univ3') {
              // Exact UniV3 quote delta for this band
              quote = L_Below * (Math.sqrt(b.pb) - Math.sqrt(b.pa));
          } else {
              quote = perBandQuoteBelow;
          }
          rows.push({
              bandIdx: b.origIdx || (idx + 1),
              pa: b.pa, pb: b.pb,
              type: 'Below',
              deployUSD: quote,        // denom spent
              deployAltUsd: 0,
              altUnitsAbove: 0,
              netAtBoundary: 0
          });
      } else {
          let units = 0;
          let quote = 0;

          if (distMode === 'univ3') {
              units = L_Above * (1 / Math.sqrt(b.pa) - 1 / Math.sqrt(b.pb));         // ALT sold in this band
              quote = L_Above * (Math.sqrt(b.pb) - Math.sqrt(b.pa));                 // denom received in this band
          } else {
              units = unitsPerBandAbove;
              const mid = Math.sqrt(b.pa * b.pb);
              quote = units * mid; // approx execution value using geometric mean price
          }

          totalAboveQuote += quote;

          rows.push({
              bandIdx: b.origIdx || (idx + 1),
              pa: b.pa, pb: b.pb,
              type: 'Above',
              deployUSD: 0,
              deployAltUsd: quote,     // denom received
              altUnitsAbove: units,    // ALT units sold
              netAtBoundary: 0
          });
      }
  });

  // For analytics / PnL, treat above "capital" as notional value of the units that need to be sold at P0.
  const aboveNotionalAtP0 = sellUnits * p0;

  return {
      rows,
      kpi: {
          Ndown, Nup,
          belowTotal: totalBelowQuote,
          aboveTotal: aboveNotionalAtP0,
          belowUnits: buyUnits,
          aboveUnits: sellUnits,
          aboveQuote: totalAboveQuote
      },
      rawBands: bands
  };
}

function renderLPSection(container, title, stratData, denomSymbol, denomUsd, assetSymbol, sectionId){
  if(!stratData){
    const div = document.createElement('div');
    div.className = 'pill bad';
    div.style.width = '100%';
    div.style.justifyContent = 'center';
    div.textContent = 'Invalid parameters.';
    container.appendChild(div);
    return;
  }

  const precision = Number(document.getElementById('precision').value) || 6;
  const hideZero = document.getElementById('hideZeroRows').value === 'hide';

  // Create section wrapper
  const section = document.createElement('div');
  section.style.marginTop = '14px';

  const header = document.createElement('div');
  header.className = 'sectionTitle';
  header.textContent = title;
  section.appendChild(header);

  // KPIs
  const kpiWrap = document.createElement('div');
  kpiWrap.className = 'kpiGrid';

  let aboveAssetSum = 0;
  let aboveDenomSum = 0;
  let belowDenomSum = 0;

  const rows = [...stratData.rows];
  rows.sort((a,b) => a.pa - b.pa);

  rows.forEach(r => {
    if(r.type === 'Above'){
      aboveAssetSum += r.altUnitsAbove || 0;
      aboveDenomSum += r.deployAltUsd || 0;
    }else{
      belowDenomSum += r.deployUSD || 0;
    }
  });

  const totalUsdAbove = aboveDenomSum * denomUsd;
  const totalUsdBelow = belowDenomSum * denomUsd;

  const kpis = [
    { label: `TOTAL ${assetSymbol} ABOVE`, value: fmt(aboveAssetSum, precision) },
    { label: `TOTAL USD ABOVE`, value: `$${fmt(totalUsdAbove, 2)}` },
    { label: `TOTAL ${denomSymbol} BELOW`, value: fmt(belowDenomSum, precision) },
    { label: `TOTAL USD BELOW`, value: `$${fmt(totalUsdBelow, 2)}` },
  ];

  kpis.forEach(k => {
    const el = document.createElement('div');
    el.className = 'kpi';
    el.innerHTML = `<div class="label">${k.label}</div><div class="value">${k.value}</div>`;
    kpiWrap.appendChild(el);
  });

  section.appendChild(kpiWrap);

  // Table
  const table = document.createElement('table');
  table.innerHTML = `
    <thead>
      <tr>
        <th>Band</th>
        <th>Range (Pᵃ → Pᵇ)</th>
        <th>Type</th>
        <th>Deployed Asset</th>
        <th>Value (USD)</th>
      </tr>
    </thead>
    <tbody></tbody>
  `;
  const tbody = table.querySelector('tbody');

  rows.forEach(r => {
    const isAbove = r.type === 'Above';
    const denomVal = isAbove ? (r.deployAltUsd || 0) : (r.deployUSD || 0);
    const usdVal = denomVal * denomUsd;
    const showRow = !(hideZero && Math.abs(usdVal) < 1e-9);
    if(!showRow) return;

    const tr = document.createElement('tr');
    const rangeStr = `${Number(r.pa).toFixed(6)} - ${Number(r.pb).toFixed(6)}`;
    const typeArrow = isAbove ? '↑' : '↓';
    const deployedStr = isAbove 
      ? `<span style="color:var(--good)">${fmt(r.altUnitsAbove || 0, precision)} ${assetSymbol}</span>` 
      : `<span style="color:var(--good)">${fmt(r.deployUSD || 0, precision)} ${denomSymbol}</span>`;

    tr.innerHTML = `
      <td>${r.bandIdx}</td>
      <td>${rangeStr}</td>
      <td style="text-align:center">${typeArrow}</td>
      <td>${deployedStr}</td>
      <td style="color:var(--muted)">$${fmt(usdVal, 2)}</td>
    `;
    tbody.appendChild(tr);
  });

  section.appendChild(table);
  container.appendChild(section);

  // header pills
  const bandsPill = document.getElementById('bandsPill');
  const modePill = document.getElementById('modePill');
  bandsPill.textContent = `${stratData.kpi.Ndown + stratData.kpi.Nup} bands`;
  modePill.textContent = document.getElementById('distMode').value === 'univ3' ? 'UniV3' : 'Uniform';
}

async function loadAssetList(){
  const sel = document.getElementById('assetSelect');
  const statusEl = document.getElementById('sheetStatus');
  if(!sel || !statusEl) { statusEl.innerHTML = '<span style="color:var(--bad)">ERROR:</span> Missing elements.'; return; }
  statusEl.textContent = 'Loading asset list...';
  sel.innerHTML = '<option value="">– Select asset –</option>';
  try{
    const res = await fetch('/api/config');
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    if(data.error){ throw new Error(data.error); }
    if(data.assets && Array.isArray(data.assets)){
      data.assets.forEach(a => {
        let sym = '';
        if (typeof a === 'string') sym = a;
        else if (a && typeof a === 'object') sym = a.symbol || a.asset || a.ticker || a.name;

        if(sym && String(sym).trim() !== ''){
          const opt = document.createElement('option');
          opt.value = String(sym).trim();
          opt.textContent = String(sym).trim();
          sel.appendChild(opt);
        }
      });
      statusEl.textContent = `Loaded ${data.assets.length} assets.`;
    } else { statusEl.textContent = 'No assets found.'; }
  }catch(err){
    console.error('Error loading asset list', err);
    statusEl.innerHTML = `<span style="color:var(--bad)">ERROR:</span> Failed to load list: ${err.message}`;
  }
}

async function loadAssetConfig(symbol){
  if(!symbol) return;
  const statusEl = document.getElementById('sheetStatus');
  statusEl.textContent = `Loading config for ${symbol}...`;
  try{
    const [configRes, portfolioRes] = await Promise.all([
      fetch(`${APPS_SCRIPT_URL}?symbol=${encodeURIComponent(symbol)}`),
      fetch('/api/portfolio-size')
    ]);
    if(!configRes.ok) throw new Error(`Config HTTP ${configRes.status}`);
    const data = await configRes.json();
    if(data.error) throw new Error(data.error);

    // Config fields expected: denomAsset, pmin, pmax, targetMinPct, targetMaxPct, pcurrent (optional)
    const denomAsset = (data.denomAsset || 'BTC').toUpperCase();
    document.getElementById('denomSelect').value = denomAsset;
    updateDenomLabels(denomAsset);

    if(data.pmin) document.getElementById('pmin').value = Number(data.pmin).toFixed(9);
    if(data.pmax) document.getElementById('pmax').value = Number(data.pmax).toFixed(9);

    if(data.targetMinPct !== undefined) document.getElementById('targetMinPct').value = Number(data.targetMinPct);
    if(data.targetMaxPct !== undefined) document.getElementById('targetMaxPct').value = Number(data.targetMaxPct);

    // portfolio size returned in USD, convert to denom using denomUsd
    let portfolioUsd = 0;
    if(portfolioRes.ok){
      const p = await portfolioRes.json();
      portfolioUsd = Number(p.total) || 0;
    }
    const denomUsd = Number(document.getElementById('denomUsd').value) || 0;
    if(denomUsd > 0 && portfolioUsd > 0){
      document.getElementById('portfolioSize').value = (portfolioUsd/denomUsd).toFixed(6);
    }

    statusEl.textContent = `Loaded config for ${symbol}.`;
    statusEl.className = 'pill good';

    // fetch prices after denom changes
    autoFetchPrices(symbol, denomAsset);
    updateAutoTargets();
  }catch(err){
    console.error(err);
    statusEl.textContent = `Sheets: failed`;
    statusEl.className = 'pill bad';
  }
}

// --- Controls ---
function clearOutputs(){
  document.getElementById('resultsContainer').innerHTML = `<div class="pill" style="width:100%; justify-content:center;">No schedules generated yet</div>`;
}

function generate() {
  const container = document.getElementById('resultsContainer');
  container.innerHTML = '';

  // Keep the display-only helpers in sync with edits and auto-loads.
  updateAutoTargets();
  updateDenomBudget();

  const pmin = Number(document.getElementById('pmin').value);
  const pmax = Number(document.getElementById('pmax').value);
  const p0 = Number(document.getElementById('p0').value);
  const stepPct = Number(document.getElementById('intervalPct').value);
  const portfolioSize = Number(document.getElementById('portfolioSize').value);
  const currentE = Number(document.getElementById('currentE').value);
  const targetMinPct = Number(document.getElementById('targetMinPct').value);
  const targetMaxPct = Number(document.getElementById('targetMaxPct').value);
  const distMode = document.getElementById('distMode').value;
  const scaleMode = document.getElementById('scaleMode').value;

  const isDual = document.getElementById('dualLpMode').checked;
  const isJlpMode = document.getElementById('jlpStrategyMode').checked;

  const strategies = [];
  let capitalRatio = isDual ? (Number(document.getElementById('dualMult').value) || 0.5) : (isJlpMode ? 0.5 : 1.0);

  const assetSymbol = (document.getElementById('assetSelect').value || 'ALT').toUpperCase();
  const denomSymbol = (document.getElementById('denomSelect').value || 'BTC').toUpperCase();
  const denomUsd = Number(document.getElementById('denomUsd').value) || 0;

  // NEW: denom-aware budget cap for Below side (scaled by capitalRatio)
  const denomBudgetTotal = Number(document.getElementById('denomBudget')?.value) || 0;
  const denomBudgetScaled = denomBudgetTotal * capitalRatio;

  const baseParams = { 
      pmin, pmax, p0, stepPct, 
      portfolioSize: portfolioSize * capitalRatio, 
      currentE: currentE * capitalRatio, 
      targetMinPct, targetMaxPct, 
      denomSymbol, denomUsd, assetSymbol, 
      scaleMode, aprPct: 0, maxDays: 0, distMode,
      denomBudget: denomBudgetScaled
  };

  strategies.push({ title: isDual ? `LP 1 (${capitalRatio}x)` : `Schedule`, id: 'lp1', params: baseParams });

  // Dual LP: second schedule in USD terms (no denom-budget cap applied here)
  if(isDual) {
        const usdPmin = pmin * denomUsd, usdPmax = pmax * denomUsd, usdP0 = p0 * denomUsd;
        strategies.push({ 
            title: `LP 2 (USD, ${capitalRatio}x)`, 
            id: 'lp2', 
            params: { 
                ...baseParams, 
                pmin: usdPmin, pmax: usdPmax, p0: usdP0,
                portfolioSize: portfolioSize * denomUsd * capitalRatio, 
                currentE: currentE * denomUsd * capitalRatio, 
                denomSymbol: 'USD', denomUsd: 1,
                denomBudget: null
            } 
        });
  }

  strategies.forEach(s => { s.data = calculateStrategy(s.params); });
  strategies.forEach(s => renderLPSection(container, s.title, s.data, s.params.denomSymbol, s.params.denomUsd, s.params.assetSymbol, s.id));
}

// --- Exposure chart (table) ---
function generateExposureSchedule(){
  // simple table display for exposure curve
  const container = document.getElementById('resultsContainer');
  const div = document.createElement('div');
  div.style.marginTop = '18px';

  const header = document.createElement('div');
  header.className = 'sectionTitle';
  header.textContent = 'Exposure Schedule';
  div.appendChild(header);

  const pmin = Number(document.getElementById('pmin').value);
  const pmax = Number(document.getElementById('pmax').value);
  const p0 = Number(document.getElementById('p0').value);
  const portSize = Number(document.getElementById('portfolioSize').value);
  const minPct = Number(document.getElementById('targetMinPct').value);
  const maxPct = Number(document.getElementById('targetMaxPct').value);
  const denomSym = document.getElementById('denomSelect').value.toUpperCase();
  const assetSym = document.getElementById('assetSelect').value.toUpperCase();
  const mode = document.getElementById('distMode').value;

  if(!(pmin>0 && pmax>pmin && p0>0)){
    const pill = document.createElement('div');
    pill.className = 'pill bad';
    pill.style.width = '100%';
    pill.style.justifyContent = 'center';
    pill.textContent = 'Invalid params for exposure curve.';
    div.appendChild(pill);
    container.appendChild(div);
    return;
  }

  const points = 41;
  const rows = [];
  for(let i=0;i<points;i++){
    const px = pmin + (pmax-pmin)*(i/(points-1));
    const u = getUnitsHeldAt(px, pmin, pmax, portSize, minPct, maxPct, mode);
    const val = u * px;
    rows.push({ px, units: u, value: val });
  }

  const table = document.createElement('table');
  table.innerHTML = `
    <thead><tr>
      <th>Price (ALT/${denomSym})</th>
      <th>Target Units (${assetSym})</th>
      <th>Target Exposure (${denomSym})</th>
    </tr></thead>
    <tbody></tbody>
  `;
  const tbody = table.querySelector('tbody');
  rows.forEach(r=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${fmt(r.px, 6)}</td>
      <td>${fmt(r.units, 6)}</td>
      <td>${fmt(r.value, 6)}</td>
    `;
    tbody.appendChild(tr);
  });

  div.appendChild(table);
  container.appendChild(div);
}

// --- PnL Schedule ---
function generatePnLSchedule(){
  const container = document.getElementById('resultsContainer');
  const div = document.createElement('div');
  div.style.marginTop = '18px';

  const header = document.createElement('div');
  header.className = 'sectionTitle';
  header.textContent = 'PnL (Simple Model)';
  div.appendChild(header);

  const pmin = Number(document.getElementById('pmin').value);
  const pmax = Number(document.getElementById('pmax').value);
  const p0 = Number(document.getElementById('p0').value);
  const stepPct = Number(document.getElementById('intervalPct').value);
  const portfolioSize = Number(document.getElementById('portfolioSize').value);
  const currentE = Number(document.getElementById('currentE').value);
  const targetMinPct = Number(document.getElementById('targetMinPct').value);
  const targetMaxPct = Number(document.getElementById('targetMaxPct').value);
  const distMode = document.getElementById('distMode').value;
  const scaleMode = document.getElementById('scaleMode').value;

  const denomSym = document.getElementById('denomSelect').value.toUpperCase();
  const denomUsd = Number(document.getElementById('denomUsd').value) || 0;
  const assetSym = document.getElementById('assetSelect').value.toUpperCase();

  const isDual = document.getElementById('dualLpMode').checked;
  let capitalRatio = isDual ? (Number(document.getElementById('dualMult').value) || 0.5) : 1.0;

  const activeBelowPct = Number(document.getElementById('activeBelowPct').value) || 0;
  const activeAbovePct = Number(document.getElementById('activeAbovePct').value) || 0;
  const aprPct = Number(document.getElementById('aprPct').value) || 0;
  const maxDays = Number(document.getElementById('maxDays').value) || 0;

  if(!(pmin>0 && pmax>pmin && p0>0 && denomUsd>0)){
    const pill = document.createElement('div');
    pill.className = 'pill bad';
    pill.style.width = '100%';
    pill.style.justifyContent = 'center';
    pill.textContent = 'Invalid params for PnL.';
    div.appendChild(pill);
    container.appendChild(div);
    return;
  }

  const denomBudgetTotal = Number(document.getElementById('denomBudget')?.value) || 0;
  const strategyParams = { 
      pmin, pmax, p0, stepPct, 
      portfolioSize: portfolioSize * capitalRatio, 
      currentE: currentE * capitalRatio, 
      targetMinPct, targetMaxPct, 
      denomSymbol: denomSym, denomUsd, assetSymbol: assetSym, 
      scaleMode, aprPct: 0, maxDays: 0, distMode,
      denomBudget: denomBudgetTotal * capitalRatio
  };

  const stratData = calculateStrategy(strategyParams);
  if(!stratData){
    const pill = document.createElement('div');
    pill.className = 'pill bad';
    pill.style.width = '100%';
    pill.style.justifyContent = 'center';
    pill.textContent = 'Strategy calc failed.';
    div.appendChild(pill);
    container.appendChild(div);
    return;
  }

  const stratCapBelow = stratData.kpi.belowTotal;
  const stratCapAbove = stratData.kpi.aboveTotal;
  const stratCapTotal = stratCapBelow + stratCapAbove;

  // simple in-range time estimate
  const activeCap = stratCapTotal * ((activeBelowPct + activeAbovePct)/100);
  const dailyApr = (aprPct/100) / 365;
  const expectedPnL = activeCap * dailyApr * maxDays;

  const table = document.createElement('table');
  table.innerHTML = `
    <thead>
      <tr>
        <th>Metric</th>
        <th>Value (${denomSym})</th>
        <th>Value (USD)</th>
      </tr>
    </thead>
    <tbody></tbody>
  `;
  const tbody = table.querySelector('tbody');

  const rows = [
    { k: 'Strategy capital (Below spend)', v: stratCapBelow },
    { k: 'Strategy capital (Above notional @P0)', v: stratCapAbove },
    { k: 'Total strategy capital', v: stratCapTotal },
    { k: `Active capital (${activeBelowPct+activeAbovePct}% active)`, v: activeCap },
    { k: `Expected PnL (${aprPct}% APR for ${maxDays} days)`, v: expectedPnL },
  ];

  rows.forEach(r=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td style="text-align:left">${r.k}</td>
      <td>${fmt(r.v, 6)}</td>
      <td style="color:var(--muted)">$${fmt(r.v*denomUsd, 2)}</td>
    `;
    tbody.appendChild(tr);
  });

  div.appendChild(table);
  container.appendChild(div);
}

// --- Target curve helper (used by optimizer + Target@P0 calc) ---
function getUnitsHeldAt(px, pmin, pmax, portSize, tMinPct, tMaxPct, mode){
  const valMin = portSize * (tMinPct / 100);
  const valMax = portSize * (tMaxPct / 100);
  const uMin = (pmin>0) ? (valMin / pmin) : 0;
  const uMax = (pmax>0) ? (valMax / pmax) : 0;

  const p = Math.max(pmin, Math.min(px, pmax));

  if(mode === 'uniform'){
    const progress = (p - pmin) / (pmax - pmin);
    const curVal = valMin + (valMax - valMin) * progress;
    return (p>0) ? (curVal / p) : 0;
  }else if(mode === 'univ3'){
    const deltaU = uMin - uMax;
    if(Math.abs(pmax - pmin) < 1e-12) return uMin;
    const invSqrtMin = 1/Math.sqrt(pmin);
    const invSqrtMax = 1/Math.sqrt(pmax);
    const L = deltaU / (invSqrtMin - invSqrtMax);
    return L * (1/Math.sqrt(p) - 1/Math.sqrt(pmax)) + uMax;
  }
  return uMin;
}

// --- Cross-Pair Optimizer (display only) ---
let snapA = null;
let snapB = null;

function captureSnapshot(which){
  const pmin = Number(document.getElementById('pmin').value);
  const pmax = Number(document.getElementById('pmax').value);
  const p0 = Number(document.getElementById('p0').value);
  const portfolioSize = Number(document.getElementById('portfolioSize').value);
  const currentE = Number(document.getElementById('currentE').value);
  const tMinPct = Number(document.getElementById('targetMinPct').value);
  const tMaxPct = Number(document.getElementById('targetMaxPct').value);
  const distMode = document.getElementById('distMode').value;

  const assetSym = (document.getElementById('assetSelect').value || 'ALT').toUpperCase();
  const denomSym = (document.getElementById('denomSelect').value || 'BTC').toUpperCase();
  const denomUsd = Number(document.getElementById('denomUsd').value) || 0;
  const altUsd = Number(document.getElementById('altUsd').value) || 0;

  const targetUnitsCurrent = getUnitsHeldAt(p0, pmin, pmax, portfolioSize, tMinPct, tMaxPct, distMode);
  const targetValDenom = targetUnitsCurrent * p0;
  const targetValUsd = targetValDenom * denomUsd;

  return {
    ts: Date.now(),
    assetSym, denomSym,
    pmin, pmax, p0,
    portfolioSize, currentE,
    tMinPct, tMaxPct, distMode,
    denomUsd, altUsd,
    targetValDenom, targetValUsd
  };
}

function renderSnapshot(elId, snap){
  const el = document.getElementById(elId);
  if(!snap){
    el.className = 'pill';
    el.textContent = 'None';
    return;
  }
  el.className = 'pill good';
  el.style.justifyContent = 'flex-start';
  const dt = new Date(snap.ts).toLocaleString();
  el.textContent = `${dt} — ${snap.assetSym}/${snap.denomSym} P₀=${fmt(snap.p0,6)} | CurrentE=${fmt(snap.currentE,4)} ${snap.denomSym} | Target@P₀=${fmt(snap.targetValDenom,4)} ${snap.denomSym}`;
}

function computeCross(){
  const out = document.getElementById('crossOut');
  const wrap = document.getElementById('crossTableWrap');
  wrap.innerHTML = '';

  if(!snapA || !snapB){
    out.className = 'pill warn';
    out.textContent = 'Capture both A and B to compute.';
    return;
  }

  // Display-only: show their Target@P0 deltas and a simple suggestion
  const deltaA = snapA.currentE - snapA.targetValDenom;
  const deltaB = snapB.currentE - snapB.targetValDenom;

  out.className = 'pill';
  out.textContent = `A Δ=${fmt(deltaA,4)} ${snapA.denomSym} | B Δ=${fmt(deltaB,4)} ${snapB.denomSym}. (Dynamic cross-strategy coming next.)`;

  const table = document.createElement('table');
  table.innerHTML = `
    <thead>
      <tr>
        <th>Side</th>
        <th>Pair</th>
        <th>P₀</th>
        <th>CurrentE</th>
        <th>Target@P₀</th>
        <th>Δ (Current-Target)</th>
      </tr>
    </thead>
    <tbody></tbody>
  `;
  const tb = table.querySelector('tbody');

  [
    { name:'A', s:snapA, d:deltaA },
    { name:'B', s:snapB, d:deltaB },
  ].forEach(row=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td style="text-align:left">${row.name}</td>
      <td style="text-align:left">${row.s.assetSym}/${row.s.denomSym}</td>
      <td>${fmt(row.s.p0,6)}</td>
      <td>${fmt(row.s.currentE,4)} ${row.s.denomSym}</td>
      <td>${fmt(row.s.targetValDenom,4)} ${row.s.denomSym}</td>
      <td style="color:${row.d>=0?'var(--good)':'var(--bad)'}">${row.d>=0?'+':''}${fmt(row.d,4)} ${row.s.denomSym}</td>
    `;
    tb.appendChild(tr);
  });

  wrap.appendChild(table);
}

document.getElementById('btnCaptureA').addEventListener('click', () => {
  snapA = captureSnapshot('A');
  renderSnapshot('captureA', snapA);
  computeCross();
});
document.getElementById('btnCaptureB').addEventListener('click', () => {
  snapB = captureSnapshot('B');
  renderSnapshot('captureB', snapB);
  computeCross();
});
document.getElementById('btnClearCross').addEventListener('click', () => {
  snapA = null; snapB = null;
  renderSnapshot('captureA', null);
  renderSnapshot('captureB', null);
  document.getElementById('crossOut').className = 'pill';
  document.getElementById('crossOut').textContent = 'Capture both A and B to compute.';
  document.getElementById('crossTableWrap').innerHTML = '';
});

// Buttons
document.getElementById('btnGen').addEventListener('click', generate);
document.getElementById('btnExposure').addEventListener('click', generateExposureSchedule);
document.getElementById('btnPnl').addEventListener('click', generatePnLSchedule);
document.getElementById('btnClear').addEventListener('click', clearOutputs);
document.getElementById('btnAutoExp').addEventListener('click', fetchLiveExposure);
document.getElementById('btnAutoPx').addEventListener('click', () => {
  const asset = document.getElementById('assetSelect').value;
  const denom = document.getElementById('denomSelect').value;
  autoFetchPrices(asset, denom);
});

// Init
(function init(){
  const denomSel = document.getElementById('denomSelect');
  const assetSel = document.getElementById('assetSelect');
  if(denomSel) updateDenomLabels(denomSel.value);

  const altUsdEl = document.getElementById('altUsd');
  const denomUsdEl = document.getElementById('denomUsd');
  const p0El = document.getElementById('p0');

  if(altUsdEl) altUsdEl.addEventListener('input', () => { updateP0FromUsd(); updateAutoTargets(); });
  if(denomUsdEl) denomUsdEl.addEventListener('input', () => { updateP0FromUsd(); updateAutoTargets(); });
  if(p0El) p0El.addEventListener('input', () => { updateUsdFromP0(); updateAutoTargets(); });

  if (assetSel) assetSel.addEventListener('change', () => loadAssetConfig(assetSel.value));
  if (denomSel) denomSel.addEventListener('change', () => {
      updateDenomLabels(denomSel.value);
      updateAutoTargets();
      updateDenomBudget();
      autoFetchPrices(assetSel ? assetSel.value : '', denomSel.value);
  });

  // Keep targets synced when users edit fields manually
  ['pmin','pmax','currentE','distMode','portfolioSize','targetMinPct','targetMaxPct'].forEach(id => {
      const el = document.getElementById(id);
      if(el) el.addEventListener('input', updateAutoTargets);
  });

  const denomTargetEl = document.getElementById('denomTargetE');
  if(denomTargetEl) denomTargetEl.addEventListener('input', () => { updateDenomBudget(); generate(); });

  loadAssetList();
  if (denomSel) autoFetchPrices('', denomSel.value);
})();
</script>
</body>
</html>
